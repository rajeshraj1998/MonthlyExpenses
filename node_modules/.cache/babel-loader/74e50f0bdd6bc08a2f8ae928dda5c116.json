{"ast":null,"code":"// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n// ----------------------------------------------------------------------------\n// This file is a polyfill for the upcoming ECMAScript Reflect API,\n// including support for Proxies. See the draft specification at:\n// http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n// For an implementation of the Handler API, see handlers.js, which implements:\n// http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n// This implementation supersedes the earlier polyfill at:\n// code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n// This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n// The code also works correctly on\n//   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n// Language Dependencies:\n//  - ECMAScript 5/strict\n//  - \"old\" (i.e. non-direct) Harmony Proxies\n//  - Harmony WeakMaps\n// Patches:\n//  - Object.{freeze,seal,preventExtensions}\n//  - Object.{isFrozen,isSealed,isExtensible}\n//  - Object.getPrototypeOf\n//  - Object.keys\n//  - Object.prototype.valueOf\n//  - Object.prototype.isPrototypeOf\n//  - Object.prototype.toString\n//  - Object.prototype.hasOwnProperty\n//  - Object.getOwnPropertyDescriptor\n//  - Object.defineProperty\n//  - Object.defineProperties\n//  - Object.getOwnPropertyNames\n//  - Object.getOwnPropertySymbols\n//  - Object.getPrototypeOf\n//  - Object.setPrototypeOf\n//  - Object.assign\n//  - Function.prototype.toString\n//  - Date.prototype.toString\n//  - Array.isArray\n//  - Array.prototype.concat\n//  - Proxy\n// Adds new globals:\n//  - Reflect\n// Direct proxies can be created via Proxy(target, handler)\n// ----------------------------------------------------------------------------\n(function (global) {\n  // function-as-module pattern\n  \"use strict\"; // === Direct Proxies: Invariant Enforcement ===\n  // Direct proxies build on non-direct proxies by automatically wrapping\n  // all user-defined proxy handlers in a Validator handler that checks and\n  // enforces ES5 invariants.\n  // A direct proxy is a proxy for an existing object called the target object.\n  // A Validator handler is a wrapper for a target proxy handler H.\n  // The Validator forwards all operations to H, but additionally\n  // performs a number of integrity checks on the results of some traps,\n  // to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n  // properties and non-extensible, sealed or frozen objects.\n  // For each property that H exposes as own, non-configurable\n  // (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n  // the Validator handler defines those properties on the target object.\n  // When the proxy becomes non-extensible, also configurable own properties\n  // are checked against the target.\n  // We will call properties that are defined on the target object\n  // \"fixed properties\".\n  // We will name fixed non-configurable properties \"sealed properties\".\n  // We will name fixed non-configurable non-writable properties \"frozen\n  // properties\".\n  // The Validator handler upholds the following invariants w.r.t. non-configurability:\n  // - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n  // - getOwnPropertyDescriptor cannot report incompatible changes to the\n  //   attributes of a sealed property (e.g. reporting a non-configurable\n  //   property as configurable, or reporting a non-configurable, non-writable\n  //   property as writable)\n  // - getPropertyDescriptor cannot report sealed properties as non-existent\n  // - getPropertyDescriptor cannot report incompatible changes to the\n  //   attributes of a sealed property. It _can_ report incompatible changes\n  //   to the attributes of non-own, inherited properties.\n  // - defineProperty cannot make incompatible changes to the attributes of\n  //   sealed properties\n  // - deleteProperty cannot report a successful deletion of a sealed property\n  // - hasOwn cannot report a sealed property as non-existent\n  // - has cannot report a sealed property as non-existent\n  // - get cannot report inconsistent values for frozen data\n  //   properties, and must report undefined for sealed accessors with an\n  //   undefined getter\n  // - set cannot report a successful assignment for frozen data\n  //   properties or sealed accessors with an undefined setter.\n  // - get{Own}PropertyNames lists all sealed properties of the target.\n  // - keys lists all enumerable sealed properties of the target.\n  // - enumerate lists all enumerable sealed properties of the target.\n  // - if a property of a non-extensible proxy is reported as non-existent,\n  //   then it must forever be reported as non-existent. This applies to\n  //   own and inherited properties and is enforced in the\n  //   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n  //   get{Own}PropertyNames, keys and enumerate traps\n  // Violation of any of these invariants by H will result in TypeError being\n  // thrown.\n  // Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n  // is invoked on the proxy, the set of own property names for the proxy is\n  // fixed. Any property name that is not fixed is called a 'new' property.\n  // The Validator upholds the following invariants regarding extensibility:\n  // - getOwnPropertyDescriptor cannot report new properties as existent\n  //   (it must report them as non-existent by returning undefined)\n  // - defineProperty cannot successfully add a new property (it must reject)\n  // - getOwnPropertyNames cannot list new properties\n  // - hasOwn cannot report true for new properties (it must report false)\n  // - keys cannot list new properties\n  // Invariants currently not enforced:\n  // - getOwnPropertyNames lists only own property names\n  // - keys lists only enumerable own property names\n  // Both traps may list more property names than are actually defined on the\n  // target.\n  // Invariants with regard to inheritance are currently not enforced.\n  // - a non-configurable potentially inherited property on a proxy with\n  //   non-mutable ancestry cannot be reported as non-existent\n  // (An object with non-mutable ancestry is a non-extensible object whose\n  // [[Prototype]] is either null or an object with non-mutable ancestry.)\n  // Changes in Handler API compared to previous harmony:proxies, see:\n  // http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n  // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n  // ----------------------------------------------------------------------------\n  // ---- WeakMap polyfill ----\n  // TODO: find a proper WeakMap polyfill\n  // define an empty WeakMap so that at least the Reflect module code\n  // will work in the absence of WeakMaps. Proxy emulation depends on\n  // actual WeakMaps, so will not work with this little shim.\n\n  if (typeof WeakMap === \"undefined\") {\n    global.WeakMap = function () {};\n\n    global.WeakMap.prototype = {\n      get: function (k) {\n        return undefined;\n      },\n      set: function (k, v) {\n        throw new Error(\"WeakMap not supported\");\n      }\n    };\n  } // ---- Normalization functions for property descriptors ----\n\n\n  function isStandardAttribute(name) {\n    return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n  } // Adapted from ES5 section 8.10.5\n\n\n  function toPropertyDescriptor(obj) {\n    if (Object(obj) !== obj) {\n      throw new TypeError(\"property descriptor should be an Object, given: \" + obj);\n    }\n\n    var desc = {};\n\n    if ('enumerable' in obj) {\n      desc.enumerable = !!obj.enumerable;\n    }\n\n    if ('configurable' in obj) {\n      desc.configurable = !!obj.configurable;\n    }\n\n    if ('value' in obj) {\n      desc.value = obj.value;\n    }\n\n    if ('writable' in obj) {\n      desc.writable = !!obj.writable;\n    }\n\n    if ('get' in obj) {\n      var getter = obj.get;\n\n      if (getter !== undefined && typeof getter !== \"function\") {\n        throw new TypeError(\"property descriptor 'get' attribute must be \" + \"callable or undefined, given: \" + getter);\n      }\n\n      desc.get = getter;\n    }\n\n    if ('set' in obj) {\n      var setter = obj.set;\n\n      if (setter !== undefined && typeof setter !== \"function\") {\n        throw new TypeError(\"property descriptor 'set' attribute must be \" + \"callable or undefined, given: \" + setter);\n      }\n\n      desc.set = setter;\n    }\n\n    if ('get' in desc || 'set' in desc) {\n      if ('value' in desc || 'writable' in desc) {\n        throw new TypeError(\"property descriptor cannot be both a data and an \" + \"accessor descriptor: \" + obj);\n      }\n    }\n\n    return desc;\n  }\n\n  function isAccessorDescriptor(desc) {\n    if (desc === undefined) return false;\n    return 'get' in desc || 'set' in desc;\n  }\n\n  function isDataDescriptor(desc) {\n    if (desc === undefined) return false;\n    return 'value' in desc || 'writable' in desc;\n  }\n\n  function isGenericDescriptor(desc) {\n    if (desc === undefined) return false;\n    return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n  }\n\n  function toCompletePropertyDescriptor(desc) {\n    var internalDesc = toPropertyDescriptor(desc);\n\n    if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n      if (!('value' in internalDesc)) {\n        internalDesc.value = undefined;\n      }\n\n      if (!('writable' in internalDesc)) {\n        internalDesc.writable = false;\n      }\n    } else {\n      if (!('get' in internalDesc)) {\n        internalDesc.get = undefined;\n      }\n\n      if (!('set' in internalDesc)) {\n        internalDesc.set = undefined;\n      }\n    }\n\n    if (!('enumerable' in internalDesc)) {\n      internalDesc.enumerable = false;\n    }\n\n    if (!('configurable' in internalDesc)) {\n      internalDesc.configurable = false;\n    }\n\n    return internalDesc;\n  }\n\n  function isEmptyDescriptor(desc) {\n    return !('get' in desc) && !('set' in desc) && !('value' in desc) && !('writable' in desc) && !('enumerable' in desc) && !('configurable' in desc);\n  }\n\n  function isEquivalentDescriptor(desc1, desc2) {\n    return sameValue(desc1.get, desc2.get) && sameValue(desc1.set, desc2.set) && sameValue(desc1.value, desc2.value) && sameValue(desc1.writable, desc2.writable) && sameValue(desc1.enumerable, desc2.enumerable) && sameValue(desc1.configurable, desc2.configurable);\n  } // copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\n\n\n  function sameValue(x, y) {\n    if (x === y) {\n      // 0 === -0, but they are not identical\n      return x !== 0 || 1 / x === 1 / y;\n    } // NaN !== NaN, but they are identical.\n    // NaNs are the only non-reflexive value, i.e., if x !== x,\n    // then x is a NaN.\n    // isNaN is broken: it converts its argument to number, so\n    // isNaN(\"foo\") => true\n\n\n    return x !== x && y !== y;\n  }\n  /**\n   * Returns a fresh property descriptor that is guaranteed\n   * to be complete (i.e. contain all the standard attributes).\n   * Additionally, any non-standard enumerable properties of\n   * attributes are copied over to the fresh descriptor.\n   *\n   * If attributes is undefined, returns undefined.\n   *\n   * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n   */\n\n\n  function normalizeAndCompletePropertyDescriptor(attributes) {\n    if (attributes === undefined) {\n      return undefined;\n    }\n\n    var desc = toCompletePropertyDescriptor(attributes); // Note: no need to call FromPropertyDescriptor(desc), as we represent\n    // \"internal\" property descriptors as proper Objects from the start\n\n    for (var name in attributes) {\n      if (!isStandardAttribute(name)) {\n        Object.defineProperty(desc, name, {\n          value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n\n    return desc;\n  }\n  /**\n   * Returns a fresh property descriptor whose standard\n   * attributes are guaranteed to be data properties of the right type.\n   * Additionally, any non-standard enumerable properties of\n   * attributes are copied over to the fresh descriptor.\n   *\n   * If attributes is undefined, will throw a TypeError.\n   *\n   * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n   */\n\n\n  function normalizePropertyDescriptor(attributes) {\n    var desc = toPropertyDescriptor(attributes); // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n    // \"internal\" property descriptors as proper Objects from the start\n\n    for (var name in attributes) {\n      if (!isStandardAttribute(name)) {\n        Object.defineProperty(desc, name, {\n          value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n\n    return desc;\n  } // store a reference to the real ES5 primitives before patching them later\n\n\n  var prim_preventExtensions = Object.preventExtensions,\n      prim_seal = Object.seal,\n      prim_freeze = Object.freeze,\n      prim_isExtensible = Object.isExtensible,\n      prim_isSealed = Object.isSealed,\n      prim_isFrozen = Object.isFrozen,\n      prim_getPrototypeOf = Object.getPrototypeOf,\n      prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      prim_defineProperty = Object.defineProperty,\n      prim_defineProperties = Object.defineProperties,\n      prim_keys = Object.keys,\n      prim_getOwnPropertyNames = Object.getOwnPropertyNames,\n      prim_getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      prim_assign = Object.assign,\n      prim_isArray = Array.isArray,\n      prim_concat = Array.prototype.concat,\n      prim_isPrototypeOf = Object.prototype.isPrototypeOf,\n      prim_hasOwnProperty = Object.prototype.hasOwnProperty; // these will point to the patched versions of the respective methods on\n  // Object. They are used within this module as the \"intrinsic\" bindings\n  // of these methods (i.e. the \"original\" bindings as defined in the spec)\n\n  var Object_isFrozen, Object_isSealed, Object_isExtensible, Object_getPrototypeOf, Object_getOwnPropertyNames;\n  /**\n   * A property 'name' is fixed if it is an own property of the target.\n   */\n\n  function isFixed(name, target) {\n    return {}.hasOwnProperty.call(target, name);\n  }\n\n  function isSealed(name, target) {\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n\n    if (desc === undefined) {\n      return false;\n    }\n\n    return desc.configurable === false;\n  }\n\n  function isSealedDesc(desc) {\n    return desc !== undefined && desc.configurable === false;\n  }\n  /**\n   * Performs all validation that Object.defineProperty performs,\n   * without actually defining the property. Returns a boolean\n   * indicating whether validation succeeded.\n   *\n   * Implementation transliterated from ES5.1 section 8.12.9\n   */\n\n\n  function isCompatibleDescriptor(extensible, current, desc) {\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n\n    if (current === undefined && extensible === true) {\n      return true;\n    }\n\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n\n    if (isGenericDescriptor(desc)) {\n      return true;\n    }\n\n    if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n\n      return true;\n    }\n\n    if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  } // ES6 7.3.11 SetIntegrityLevel\n  // level is one of \"sealed\" or \"frozen\"\n\n\n  function setIntegrityLevel(target, level) {\n    var ownProps = Object_getOwnPropertyNames(target);\n    var pendingException = undefined;\n\n    if (level === \"sealed\") {\n      var l = +ownProps.length;\n      var k;\n\n      for (var i = 0; i < l; i++) {\n        k = String(ownProps[i]);\n\n        try {\n          Object.defineProperty(target, k, {\n            configurable: false\n          });\n        } catch (e) {\n          if (pendingException === undefined) {\n            pendingException = e;\n          }\n        }\n      }\n    } else {\n      // level === \"frozen\"\n      var l = +ownProps.length;\n      var k;\n\n      for (var i = 0; i < l; i++) {\n        k = String(ownProps[i]);\n\n        try {\n          var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n\n          if (currentDesc !== undefined) {\n            var desc;\n\n            if (isAccessorDescriptor(currentDesc)) {\n              desc = {\n                configurable: false\n              };\n            } else {\n              desc = {\n                configurable: false,\n                writable: false\n              };\n            }\n\n            Object.defineProperty(target, k, desc);\n          }\n        } catch (e) {\n          if (pendingException === undefined) {\n            pendingException = e;\n          }\n        }\n      }\n    }\n\n    if (pendingException !== undefined) {\n      throw pendingException;\n    }\n\n    return Reflect.preventExtensions(target);\n  } // ES6 7.3.12 TestIntegrityLevel\n  // level is one of \"sealed\" or \"frozen\"\n\n\n  function testIntegrityLevel(target, level) {\n    var isExtensible = Object_isExtensible(target);\n    if (isExtensible) return false;\n    var ownProps = Object_getOwnPropertyNames(target);\n    var pendingException = undefined;\n    var configurable = false;\n    var writable = false;\n    var l = +ownProps.length;\n    var k;\n    var currentDesc;\n\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n\n      try {\n        currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        configurable = configurable || currentDesc.configurable;\n\n        if (isDataDescriptor(currentDesc)) {\n          writable = writable || currentDesc.writable;\n        }\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n          configurable = true;\n        }\n      }\n    }\n\n    if (pendingException !== undefined) {\n      throw pendingException;\n    }\n\n    if (level === \"frozen\" && writable === true) {\n      return false;\n    }\n\n    if (configurable === true) {\n      return false;\n    }\n\n    return true;\n  } // ---- The Validator handler wrapper around user handlers ----\n\n  /**\n   * @param target the object wrapped by this proxy.\n   * As long as the proxy is extensible, only non-configurable properties\n   * are checked against the target. Once the proxy becomes non-extensible,\n   * invariants w.r.t. non-extensibility are also enforced.\n   *\n   * @param handler the handler of the direct proxy. The object emulated by\n   * this handler is validated against the target object of the direct proxy.\n   * Any violations that the handler makes against the invariants\n   * of the target will cause a TypeError to be thrown.\n   *\n   * Both target and handler must be proper Objects at initialization time.\n   */\n\n\n  function Validator(target, handler) {\n    // for non-revokable proxies, these are const references\n    // for revokable proxies, on revocation:\n    // - this.target is set to null\n    // - this.handler is set to a handler that throws on all traps\n    this.target = target;\n    this.handler = handler;\n  }\n\n  Validator.prototype = {\n    /**\n     * If getTrap returns undefined, the caller should perform the\n     * default forwarding behavior.\n     * If getTrap returns normally otherwise, the return value\n     * will be a callable trap function. When calling the trap function,\n     * the caller is responsible for binding its |this| to |this.handler|.\n     */\n    getTrap: function (trapName) {\n      var trap = this.handler[trapName];\n\n      if (trap === undefined) {\n        // the trap was not defined,\n        // perform the default forwarding behavior\n        return undefined;\n      }\n\n      if (typeof trap !== \"function\") {\n        throw new TypeError(trapName + \" trap is not callable: \" + trap);\n      }\n\n      return trap;\n    },\n    // === fundamental traps ===\n\n    /**\n     * If name denotes a fixed property, check:\n     *   - whether targetHandler reports it as existent\n     *   - whether the returned descriptor is compatible with the fixed property\n     * If the proxy is non-extensible, check:\n     *   - whether name is not a new property\n     * Additionally, the returned descriptor is normalized and completed.\n     */\n    getOwnPropertyDescriptor: function (name) {\n      \"use strict\";\n\n      var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n\n      if (trap === undefined) {\n        return Reflect.getOwnPropertyDescriptor(this.target, name);\n      }\n\n      name = String(name);\n      var desc = trap.call(this.handler, this.target, name);\n      desc = normalizeAndCompletePropertyDescriptor(desc);\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n\n      if (desc === undefined) {\n        if (isSealedDesc(targetDesc)) {\n          throw new TypeError(\"cannot report non-configurable property '\" + name + \"' as non-existent\");\n        }\n\n        if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n        }\n\n        return undefined;\n      } // at this point, we know (desc !== undefined), i.e.\n      // targetHandler reports 'name' as an existing property\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot report a new own property '\" + name + \"' on a non-extensible object\");\n        }\n      }\n\n      if (name !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot report incompatible property descriptor \" + \"for property '\" + name + \"'\");\n        }\n      }\n\n      if (desc.configurable === false) {\n        if (targetDesc === undefined || targetDesc.configurable === true) {\n          // if the property is configurable or non-existent on the target,\n          // but is reported as a non-configurable property, it may later be\n          // reported as configurable or non-existent, which violates the\n          // invariant that if the property might change or disappear, the\n          // configurable attribute must be true.\n          throw new TypeError(\"cannot report a non-configurable descriptor \" + \"for configurable or non-existent property '\" + name + \"'\");\n        }\n\n        if ('writable' in desc && desc.writable === false) {\n          if (targetDesc.writable === true) {\n            // if the property is non-configurable, writable on the target,\n            // but is reported as non-configurable, non-writable, it may later\n            // be reported as non-configurable, writable again, which violates\n            // the invariant that a non-configurable, non-writable property\n            // may not change state.\n            throw new TypeError(\"cannot report non-configurable, writable property '\" + name + \"' as non-configurable, non-writable\");\n          }\n        }\n      }\n\n      return desc;\n    },\n\n    /**\n     * In the direct proxies design with refactored prototype climbing,\n     * this trap is deprecated. For proxies-as-prototypes, instead\n     * of calling this trap, the get, set, has or enumerate traps are\n     * called instead.\n     *\n     * In this implementation, we \"abuse\" getPropertyDescriptor to\n     * support trapping the get or set traps for proxies-as-prototypes.\n     * We do this by returning a getter/setter pair that invokes\n     * the corresponding traps.\n     *\n     * While this hack works for inherited property access, it has some\n     * quirks:\n     *\n     * In Firefox, this trap is only called after a prior invocation\n     * of the 'has' trap has returned true. Hence, expect the following\n     * behavior:\n     * <code>\n     * var child = Object.create(Proxy(target, handler));\n     * child[name] // triggers handler.has(target, name)\n     * // if that returns true, triggers handler.get(target, name, child)\n     * </code>\n     *\n     * On v8, the 'in' operator, when applied to an object that inherits\n     * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n     * That calls the below getPropertyDescriptor trap on the proxy. The\n     * result of the 'in'-operator is then determined by whether this trap\n     * returns undefined or a property descriptor object. That is why\n     * we first explicitly trigger the 'has' trap to determine whether\n     * the property exists.\n     *\n     * This has the side-effect that when enumerating properties on\n     * an object that inherits from a proxy in v8, only properties\n     * for which 'has' returns true are returned:\n     *\n     * <code>\n     * var child = Object.create(Proxy(target, handler));\n     * for (var prop in child) {\n     *   // only enumerates prop if (prop in child) returns true\n     * }\n     * </code>\n     */\n    getPropertyDescriptor: function (name) {\n      var handler = this;\n      if (!handler.has(name)) return undefined;\n      return {\n        get: function () {\n          return handler.get(this, name);\n        },\n        set: function (val) {\n          if (handler.set(this, name, val)) {\n            return val;\n          } else {\n            throw new TypeError(\"failed assignment to \" + name);\n          }\n        },\n        enumerable: true,\n        configurable: true\n      };\n    },\n\n    /**\n     * If name denotes a fixed property, check for incompatible changes.\n     * If the proxy is non-extensible, check that new properties are rejected.\n     */\n    defineProperty: function (name, desc) {\n      // TODO(tvcutsem): the current tracemonkey implementation of proxies\n      // auto-completes 'desc', which is not correct. 'desc' should be\n      // normalized, but not completed. Consider:\n      // Object.defineProperty(proxy, 'foo', {enumerable:false})\n      // This trap will receive desc =\n      //  {value:undefined,writable:false,enumerable:false,configurable:false}\n      // This will also set all other attributes to their default value,\n      // which is unexpected and different from [[DefineOwnProperty]].\n      // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n      var trap = this.getTrap(\"defineProperty\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.defineProperty(this.target, name, desc);\n      }\n\n      name = String(name);\n      var descObj = normalizePropertyDescriptor(desc);\n      var success = trap.call(this.handler, this.target, name, descObj);\n      success = !!success; // coerce to Boolean\n\n      if (success === true) {\n        var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n        var extensible = Object.isExtensible(this.target); // Note: we could collapse the following two if-tests into a single\n        // test. Separating out the cases to improve error reporting.\n\n        if (!extensible) {\n          if (targetDesc === undefined) {\n            throw new TypeError(\"cannot successfully add a new property '\" + name + \"' to a non-extensible object\");\n          }\n        }\n\n        if (targetDesc !== undefined) {\n          if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n            throw new TypeError(\"cannot define incompatible property \" + \"descriptor for property '\" + name + \"'\");\n          }\n\n          if (isDataDescriptor(targetDesc) && targetDesc.configurable === false && targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\"cannot successfully define non-configurable, writable \" + \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n        }\n\n        if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n          // if the property is configurable or non-existent on the target,\n          // but is successfully being redefined as a non-configurable property,\n          // it may later be reported as configurable or non-existent, which violates\n          // the invariant that if the property might change or disappear, the\n          // configurable attribute must be true.\n          throw new TypeError(\"cannot successfully define a non-configurable \" + \"descriptor for configurable or non-existent property '\" + name + \"'\");\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * On success, check whether the target object is indeed non-extensible.\n     */\n    preventExtensions: function () {\n      var trap = this.getTrap(\"preventExtensions\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.preventExtensions(this.target);\n      }\n\n      var success = trap.call(this.handler, this.target);\n      success = !!success; // coerce to Boolean\n\n      if (success) {\n        if (Object_isExtensible(this.target)) {\n          throw new TypeError(\"can't report extensible object as non-extensible: \" + this.target);\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * If name denotes a sealed property, check whether handler rejects.\n     */\n    delete: function (name) {\n      \"use strict\";\n\n      var trap = this.getTrap(\"deleteProperty\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.deleteProperty(this.target, name);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name);\n      res = !!res; // coerce to Boolean\n\n      var targetDesc;\n\n      if (res === true) {\n        targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n\n        if (targetDesc !== undefined && targetDesc.configurable === false) {\n          throw new TypeError(\"property '\" + name + \"' is non-configurable \" + \"and can't be deleted\");\n        }\n\n        if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n          // if the property still exists on a non-extensible target but\n          // is reported as successfully deleted, it may later be reported\n          // as present, which violates the invariant that an own property,\n          // deleted from a non-extensible object cannot reappear.\n          throw new TypeError(\"cannot successfully delete existing property '\" + name + \"' on a non-extensible object\");\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n     * which now also returns an array (of strings or symbols) and\n     * which performs the same rigorous invariant checks as getOwnPropertyNames\n     *\n     * See issue #48 on how this trap can still get invoked by external libs\n     * that don't use the patched Object.getOwnPropertyNames function.\n     */\n    getOwnPropertyNames: function () {\n      // Note: removed deprecation warning to avoid dependency on 'console'\n      // (and on node, should anyway use util.deprecate). Deprecation warnings\n      // can also be annoying when they are outside of the user's control, e.g.\n      // when an external library calls unpatched Object.getOwnPropertyNames.\n      // Since there is a clean fallback to `ownKeys`, the fact that the\n      // deprecated method is still called is mostly harmless anyway.\n      // See also issues #65 and #66.\n      // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n      return this.ownKeys();\n    },\n\n    /**\n     * Checks whether the trap result does not contain any new properties\n     * if the proxy is non-extensible.\n     *\n     * Any own non-configurable properties of the target that are not included\n     * in the trap result give rise to a TypeError. As such, we check whether the\n     * returned result contains at least all sealed properties of the target\n     * object.\n     *\n     * Additionally, the trap result is normalized.\n     * Instead of returning the trap result directly:\n     *  - create and return a fresh Array,\n     *  - of which each element is coerced to a String\n     *\n     * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n     * and Object.keys (the latter filters out only the enumerable own properties).\n     */\n    ownKeys: function () {\n      var trap = this.getTrap(\"ownKeys\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.ownKeys(this.target);\n      }\n\n      var trapResult = trap.call(this.handler, this.target); // propNames is used as a set of strings\n\n      var propNames = Object.create(null);\n      var numProps = +trapResult.length;\n      var result = new Array(numProps);\n\n      for (var i = 0; i < numProps; i++) {\n        var s = String(trapResult[i]);\n\n        if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n          // non-extensible proxies don't tolerate new own property names\n          throw new TypeError(\"ownKeys trap cannot list a new \" + \"property '\" + s + \"' on a non-extensible object\");\n        }\n\n        propNames[s] = true;\n        result[i] = s;\n      }\n\n      var ownProps = Object_getOwnPropertyNames(this.target);\n      var target = this.target;\n      ownProps.forEach(function (ownProp) {\n        if (!propNames[ownProp]) {\n          if (isSealed(ownProp, target)) {\n            throw new TypeError(\"ownKeys trap failed to include \" + \"non-configurable property '\" + ownProp + \"'\");\n          }\n\n          if (!Object.isExtensible(target) && isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\" + ownProp + \"' as non-existent on a non-extensible object\");\n          }\n        }\n      });\n      return result;\n    },\n\n    /**\n     * Checks whether the trap result is consistent with the state of the\n     * wrapped target.\n     */\n    isExtensible: function () {\n      var trap = this.getTrap(\"isExtensible\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.isExtensible(this.target);\n      }\n\n      var result = trap.call(this.handler, this.target);\n      result = !!result; // coerce to Boolean\n\n      var state = Object_isExtensible(this.target);\n\n      if (result !== state) {\n        if (result) {\n          throw new TypeError(\"cannot report non-extensible object as extensible: \" + this.target);\n        } else {\n          throw new TypeError(\"cannot report extensible object as non-extensible: \" + this.target);\n        }\n      }\n\n      return state;\n    },\n\n    /**\n     * Check whether the trap result corresponds to the target's [[Prototype]]\n     */\n    getPrototypeOf: function () {\n      var trap = this.getTrap(\"getPrototypeOf\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.getPrototypeOf(this.target);\n      }\n\n      var allegedProto = trap.call(this.handler, this.target);\n\n      if (!Object_isExtensible(this.target)) {\n        var actualProto = Object_getPrototypeOf(this.target);\n\n        if (!sameValue(allegedProto, actualProto)) {\n          throw new TypeError(\"prototype value does not match: \" + this.target);\n        }\n      }\n\n      return allegedProto;\n    },\n\n    /**\n     * If target is non-extensible and setPrototypeOf trap returns true,\n     * check whether the trap result corresponds to the target's [[Prototype]]\n     */\n    setPrototypeOf: function (newProto) {\n      var trap = this.getTrap(\"setPrototypeOf\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.setPrototypeOf(this.target, newProto);\n      }\n\n      var success = trap.call(this.handler, this.target, newProto);\n      success = !!success;\n\n      if (success && !Object_isExtensible(this.target)) {\n        var actualProto = Object_getPrototypeOf(this.target);\n\n        if (!sameValue(newProto, actualProto)) {\n          throw new TypeError(\"prototype value does not match: \" + this.target);\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * In the direct proxies design with refactored prototype climbing,\n     * this trap is deprecated. For proxies-as-prototypes, for-in will\n     * call the enumerate() trap. If that trap is not defined, the\n     * operation is forwarded to the target, no more fallback on this\n     * fundamental trap.\n     */\n    getPropertyNames: function () {\n      throw new TypeError(\"getPropertyNames trap is deprecated\");\n    },\n    // === derived traps ===\n\n    /**\n     * If name denotes a fixed property, check whether the trap returns true.\n     */\n    has: function (name) {\n      var trap = this.getTrap(\"has\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.has(this.target, name);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name);\n      res = !!res; // coerce to Boolean\n\n      if (res === false) {\n        if (isSealed(name, this.target)) {\n          throw new TypeError(\"cannot report existing non-configurable own \" + \"property '\" + name + \"' as a non-existent \" + \"property\");\n        }\n\n        if (!Object.isExtensible(this.target) && isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n        }\n      } // if res === true, we don't need to check for extensibility\n      // even for a non-extensible proxy that has no own name property,\n      // the property may have been inherited\n\n\n      return res;\n    },\n\n    /**\n     * If name denotes a fixed non-configurable, non-writable data property,\n     * check its return value against the previously asserted value of the\n     * fixed property.\n     */\n    get: function (receiver, name) {\n      // experimental support for invoke() trap on platforms that\n      // support __noSuchMethod__\n\n      /*\n      if (name === '__noSuchMethod__') {\n        var handler = this;\n        return function(name, args) {\n          return handler.invoke(receiver, name, args);\n        }\n      }\n      */\n      var trap = this.getTrap(\"get\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.get(this.target, name, receiver);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name, receiver);\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name); // check consistency of the returned value\n\n      if (fixedDesc !== undefined) {\n        // getting an existing property\n        if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n          // own frozen data property\n          if (!sameValue(res, fixedDesc.value)) {\n            throw new TypeError(\"cannot report inconsistent value for \" + \"non-writable, non-configurable property '\" + name + \"'\");\n          }\n        } else {\n          // it's an accessor property\n          if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.get === undefined) {\n            if (res !== undefined) {\n              throw new TypeError(\"must report undefined for non-configurable \" + \"accessor property '\" + name + \"' without getter\");\n            }\n          }\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * If name denotes a fixed non-configurable, non-writable data property,\n     * check that the trap rejects the assignment.\n     */\n    set: function (receiver, name, val) {\n      var trap = this.getTrap(\"set\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.set(this.target, name, val, receiver);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name, val, receiver);\n      res = !!res; // coerce to Boolean\n      // if success is reported, check whether property is truly assignable\n\n      if (res === true) {\n        var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n\n        if (fixedDesc !== undefined) {\n          // setting an existing property\n          if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n            if (!sameValue(val, fixedDesc.value)) {\n              throw new TypeError(\"cannot successfully assign to a \" + \"non-writable, non-configurable property '\" + name + \"'\");\n            }\n          } else {\n            if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && // non-configurable\n            fixedDesc.set === undefined) {\n              // accessor with undefined setter\n              throw new TypeError(\"setting a property '\" + name + \"' that has \" + \" only a getter\");\n            }\n          }\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * Any own enumerable non-configurable properties of the target that are not\n     * included in the trap result give rise to a TypeError. As such, we check\n     * whether the returned result contains at least all sealed enumerable properties\n     * of the target object.\n     *\n     * The trap should return an iterator.\n     *\n     * However, as implementations of pre-direct proxies still expect enumerate\n     * to return an array of strings, we convert the iterator into an array.\n     */\n    enumerate: function () {\n      var trap = this.getTrap(\"enumerate\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        var trapResult = Reflect.enumerate(this.target);\n        var result = [];\n        var nxt = trapResult.next();\n\n        while (!nxt.done) {\n          result.push(String(nxt.value));\n          nxt = trapResult.next();\n        }\n\n        return result;\n      }\n\n      var trapResult = trap.call(this.handler, this.target);\n\n      if (trapResult === null || trapResult === undefined || trapResult.next === undefined) {\n        throw new TypeError(\"enumerate trap should return an iterator, got: \" + trapResult);\n      } // propNames is used as a set of strings\n\n\n      var propNames = Object.create(null); // var numProps = +trapResult.length;\n\n      var result = []; // new Array(numProps);\n      // trapResult is supposed to be an iterator\n      // drain iterator to array as current implementations still expect\n      // enumerate to return an array of strings\n\n      var nxt = trapResult.next();\n\n      while (!nxt.done) {\n        var s = String(nxt.value);\n\n        if (propNames[s]) {\n          throw new TypeError(\"enumerate trap cannot list a \" + \"duplicate property '\" + s + \"'\");\n        }\n\n        propNames[s] = true;\n        result.push(s);\n        nxt = trapResult.next();\n      }\n      /*for (var i = 0; i < numProps; i++) {\n        var s = String(trapResult[i]);\n        if (propNames[s]) {\n          throw new TypeError(\"enumerate trap cannot list a \"+\n                              \"duplicate property '\"+s+\"'\");\n        }\n         propNames[s] = true;\n        result[i] = s;\n      } */\n\n\n      var ownEnumerableProps = Object.keys(this.target);\n      var target = this.target;\n      ownEnumerableProps.forEach(function (ownEnumerableProp) {\n        if (!propNames[ownEnumerableProp]) {\n          if (isSealed(ownEnumerableProp, target)) {\n            throw new TypeError(\"enumerate trap failed to include \" + \"non-configurable enumerable property '\" + ownEnumerableProp + \"'\");\n          }\n\n          if (!Object.isExtensible(target) && isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\" + ownEnumerableProp + \"' as non-existent on a \" + \"non-extensible object\");\n          }\n        }\n      });\n      return result;\n    },\n\n    /**\n     * The iterate trap is deprecated by the enumerate trap.\n     */\n    iterate: Validator.prototype.enumerate,\n\n    /**\n     * Any own non-configurable properties of the target that are not included\n     * in the trap result give rise to a TypeError. As such, we check whether the\n     * returned result contains at least all sealed properties of the target\n     * object.\n     *\n     * The trap result is normalized.\n     * The trap result is not returned directly. Instead:\n     *  - create and return a fresh Array,\n     *  - of which each element is coerced to String,\n     *  - which does not contain duplicates\n     *\n     * FIXME: keys trap is deprecated\n     */\n\n    /*\n    keys: function() {\n      var trap = this.getTrap(\"keys\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.keys(this.target);\n      }\n       var trapResult = trap.call(this.handler, this.target);\n       // propNames is used as a set of strings\n      var propNames = Object.create(null);\n      var numProps = +trapResult.length;\n      var result = new Array(numProps);\n       for (var i = 0; i < numProps; i++) {\n       var s = String(trapResult[i]);\n       if (propNames[s]) {\n         throw new TypeError(\"keys trap cannot list a \"+\n                             \"duplicate property '\"+s+\"'\");\n       }\n       if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n         // non-extensible proxies don't tolerate new own property names\n         throw new TypeError(\"keys trap cannot list a new \"+\n                             \"property '\"+s+\"' on a non-extensible object\");\n       }\n        propNames[s] = true;\n       result[i] = s;\n      }\n       var ownEnumerableProps = Object.keys(this.target);\n      var target = this.target;\n      ownEnumerableProps.forEach(function (ownEnumerableProp) {\n        if (!propNames[ownEnumerableProp]) {\n          if (isSealed(ownEnumerableProp, target)) {\n            throw new TypeError(\"keys trap failed to include \"+\n                                \"non-configurable enumerable property '\"+\n                                ownEnumerableProp+\"'\");\n          }\n          if (!Object.isExtensible(target) &&\n              isFixed(ownEnumerableProp, target)) {\n              // if handler is allowed not to report ownEnumerableProp as an own\n              // property, we cannot guarantee that it will never report it as\n              // an own property later. Once a property has been reported as\n              // non-existent on a non-extensible object, it should forever be\n              // reported as non-existent\n              throw new TypeError(\"cannot report existing own property '\"+\n                                  ownEnumerableProp+\"' as non-existent on a \"+\n                                  \"non-extensible object\");\n          }\n        }\n      });\n       return result;\n    },\n    */\n\n    /**\n     * New trap that reifies [[Call]].\n     * If the target is a function, then a call to\n     *   proxy(...args)\n     * Triggers this trap\n     */\n    apply: function (target, thisBinding, args) {\n      var trap = this.getTrap(\"apply\");\n\n      if (trap === undefined) {\n        return Reflect.apply(target, thisBinding, args);\n      }\n\n      if (typeof this.target === \"function\") {\n        return trap.call(this.handler, target, thisBinding, args);\n      } else {\n        throw new TypeError(\"apply: \" + target + \" is not a function\");\n      }\n    },\n\n    /**\n     * New trap that reifies [[Construct]].\n     * If the target is a function, then a call to\n     *   new proxy(...args)\n     * Triggers this trap\n     */\n    construct: function (target, args, newTarget) {\n      var trap = this.getTrap(\"construct\");\n\n      if (trap === undefined) {\n        return Reflect.construct(target, args, newTarget);\n      }\n\n      if (typeof target !== \"function\") {\n        throw new TypeError(\"new: \" + target + \" is not a function\");\n      }\n\n      if (newTarget === undefined) {\n        newTarget = target;\n      } else {\n        if (typeof newTarget !== \"function\") {\n          throw new TypeError(\"new: \" + newTarget + \" is not a function\");\n        }\n      }\n\n      return trap.call(this.handler, target, args, newTarget);\n    }\n  }; // ---- end of the Validator handler wrapper handler ----\n  // In what follows, a 'direct proxy' is a proxy\n  // whose handler is a Validator. Such proxies can be made non-extensible,\n  // sealed or frozen without losing the ability to trap.\n  // maps direct proxies to their Validator handlers\n\n  var directProxies = new WeakMap(); // patch Object.{preventExtensions,seal,freeze} so that\n  // they recognize fixable proxies and act accordingly\n\n  Object.preventExtensions = function (subject) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      if (vhandler.preventExtensions()) {\n        return subject;\n      } else {\n        throw new TypeError(\"preventExtensions on \" + subject + \" rejected\");\n      }\n    } else {\n      return prim_preventExtensions(subject);\n    }\n  };\n\n  Object.seal = function (subject) {\n    setIntegrityLevel(subject, \"sealed\");\n    return subject;\n  };\n\n  Object.freeze = function (subject) {\n    setIntegrityLevel(subject, \"frozen\");\n    return subject;\n  };\n\n  Object.isExtensible = Object_isExtensible = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.isExtensible();\n    } else {\n      return prim_isExtensible(subject);\n    }\n  };\n\n  Object.isSealed = Object_isSealed = function (subject) {\n    return testIntegrityLevel(subject, \"sealed\");\n  };\n\n  Object.isFrozen = Object_isFrozen = function (subject) {\n    return testIntegrityLevel(subject, \"frozen\");\n  };\n\n  Object.getPrototypeOf = Object_getPrototypeOf = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.getPrototypeOf();\n    } else {\n      return prim_getPrototypeOf(subject);\n    }\n  }; // patch Object.getOwnPropertyDescriptor to directly call\n  // the Validator.prototype.getOwnPropertyDescriptor trap\n  // This is to circumvent an assertion in the built-in Proxy\n  // trapping mechanism of v8, which disallows that trap to\n  // return non-configurable property descriptors (as per the\n  // old Proxy design)\n\n\n  Object.getOwnPropertyDescriptor = function (subject, name) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      return vhandler.getOwnPropertyDescriptor(name);\n    } else {\n      return prim_getOwnPropertyDescriptor(subject, name);\n    }\n  }; // patch Object.defineProperty to directly call\n  // the Validator.prototype.defineProperty trap\n  // This is to circumvent two issues with the built-in\n  // trap mechanism:\n  // 1) the current tracemonkey implementation of proxies\n  // auto-completes 'desc', which is not correct. 'desc' should be\n  // normalized, but not completed. Consider:\n  // Object.defineProperty(proxy, 'foo', {enumerable:false})\n  // This trap will receive desc =\n  //  {value:undefined,writable:false,enumerable:false,configurable:false}\n  // This will also set all other attributes to their default value,\n  // which is unexpected and different from [[DefineOwnProperty]].\n  // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n  // 2) the current spidermonkey implementation does not\n  // throw an exception when this trap returns 'false', but instead silently\n  // ignores the operation (this is regardless of strict-mode)\n  // 2a) v8 does throw an exception for this case, but includes the rather\n  //     unhelpful error message:\n  // 'Proxy handler #<Object> returned false from 'defineProperty' trap'\n\n\n  Object.defineProperty = function (subject, name, desc) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      var normalizedDesc = normalizePropertyDescriptor(desc);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\" + name + \"'\");\n      }\n\n      return subject;\n    } else {\n      return prim_defineProperty(subject, name, desc);\n    }\n  };\n\n  Object.defineProperties = function (subject, descs) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      var names = Object.keys(descs);\n\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n        var success = vhandler.defineProperty(name, normalizedDesc);\n\n        if (success === false) {\n          throw new TypeError(\"can't redefine property '\" + name + \"'\");\n        }\n      }\n\n      return subject;\n    } else {\n      return prim_defineProperties(subject, descs);\n    }\n  };\n\n  Object.keys = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      var ownKeys = vHandler.ownKeys();\n      var result = [];\n\n      for (var i = 0; i < ownKeys.length; i++) {\n        var k = String(ownKeys[i]);\n        var desc = Object.getOwnPropertyDescriptor(subject, k);\n\n        if (desc !== undefined && desc.enumerable === true) {\n          result.push(k);\n        }\n      }\n\n      return result;\n    } else {\n      return prim_keys(subject);\n    }\n  };\n\n  Object.getOwnPropertyNames = Object_getOwnPropertyNames = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.ownKeys();\n    } else {\n      return prim_getOwnPropertyNames(subject);\n    }\n  }; // fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n  // throws an error)\n\n\n  if (prim_getOwnPropertySymbols !== undefined) {\n    Object.getOwnPropertySymbols = function (subject) {\n      var vHandler = directProxies.get(subject);\n\n      if (vHandler !== undefined) {\n        // as this shim does not support symbols, a Proxy never advertises\n        // any symbol-valued own properties\n        return [];\n      } else {\n        return prim_getOwnPropertySymbols(subject);\n      }\n    };\n  } // fixes issue #72 ('Illegal access' error when using Object.assign)\n  // Object.assign polyfill based on a polyfill posted on MDN: \n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n  //  Global_Objects/Object/assign\n  // Note that this polyfill does not support Symbols, but this Proxy Shim\n  // does not support Symbols anyway.\n\n\n  if (prim_assign !== undefined) {\n    Object.assign = function (target) {\n      // check if any argument is a proxy object\n      var noProxies = true;\n\n      for (var i = 0; i < arguments.length; i++) {\n        var vHandler = directProxies.get(arguments[i]);\n\n        if (vHandler !== undefined) {\n          noProxies = false;\n          break;\n        }\n      }\n\n      if (noProxies) {\n        // not a single argument is a proxy, perform built-in algorithm\n        return prim_assign.apply(Object, arguments);\n      } // there is at least one proxy argument, use the polyfill\n\n\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } // returns whether an argument is a reference to an object,\n  // which is legal as a WeakMap key.\n\n\n  function isObject(arg) {\n    var type = typeof arg;\n    return type === 'object' && arg !== null || type === 'function';\n  }\n\n  ; // a wrapper for WeakMap.get which returns the undefined value\n  // for keys that are not objects (in which case the underlying\n  // WeakMap would have thrown a TypeError).\n\n  function safeWeakMapGet(map, key) {\n    return isObject(key) ? map.get(key) : undefined;\n  }\n\n  ; // returns a new function of zero arguments that recursively\n  // unwraps any proxies specified as the |this|-value.\n  // The primitive is assumed to be a zero-argument method\n  // that uses its |this|-binding.\n\n  function makeUnwrapping0ArgMethod(primitive) {\n    return function builtin() {\n      var vHandler = safeWeakMapGet(directProxies, this);\n\n      if (vHandler !== undefined) {\n        return builtin.call(vHandler.target);\n      } else {\n        return primitive.call(this);\n      }\n    };\n  }\n\n  ; // returns a new function of 1 arguments that recursively\n  // unwraps any proxies specified as the |this|-value.\n  // The primitive is assumed to be a 1-argument method\n  // that uses its |this|-binding.\n\n  function makeUnwrapping1ArgMethod(primitive) {\n    return function builtin(arg) {\n      var vHandler = safeWeakMapGet(directProxies, this);\n\n      if (vHandler !== undefined) {\n        return builtin.call(vHandler.target, arg);\n      } else {\n        return primitive.call(this, arg);\n      }\n    };\n  }\n\n  ;\n  Object.prototype.valueOf = makeUnwrapping0ArgMethod(Object.prototype.valueOf);\n  Object.prototype.toString = makeUnwrapping0ArgMethod(Object.prototype.toString);\n  Function.prototype.toString = makeUnwrapping0ArgMethod(Function.prototype.toString);\n  Date.prototype.toString = makeUnwrapping0ArgMethod(Date.prototype.toString);\n\n  Object.prototype.isPrototypeOf = function builtin(arg) {\n    // bugfix thanks to Bill Mark:\n    // built-in isPrototypeOf does not unwrap proxies used\n    // as arguments. So, we implement the builtin ourselves,\n    // based on the ECMAScript 6 spec. Our encoding will\n    // make sure that if a proxy is used as an argument,\n    // its getPrototypeOf trap will be called.\n    while (true) {\n      var vHandler2 = safeWeakMapGet(directProxies, arg);\n\n      if (vHandler2 !== undefined) {\n        arg = vHandler2.getPrototypeOf();\n\n        if (arg === null) {\n          return false;\n        } else if (sameValue(arg, this)) {\n          return true;\n        }\n      } else {\n        return prim_isPrototypeOf.call(this, arg);\n      }\n    }\n  };\n\n  Array.isArray = function (subject) {\n    var vHandler = safeWeakMapGet(directProxies, subject);\n\n    if (vHandler !== undefined) {\n      return Array.isArray(vHandler.target);\n    } else {\n      return prim_isArray(subject);\n    }\n  };\n\n  function isProxyArray(arg) {\n    var vHandler = safeWeakMapGet(directProxies, arg);\n\n    if (vHandler !== undefined) {\n      return Array.isArray(vHandler.target);\n    }\n\n    return false;\n  } // Array.prototype.concat internally tests whether one of its\n  // arguments is an Array, by checking whether [[Class]] == \"Array\"\n  // As such, it will fail to recognize proxies-for-arrays as arrays.\n  // We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n  // by making a copy. This will trigger the exact same sequence of\n  // traps on the proxy-for-array as if we would not have unwrapped it.\n  // See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\n\n\n  Array.prototype.concat = function ()\n  /*...args*/\n  {\n    var length;\n\n    for (var i = 0; i < arguments.length; i++) {\n      if (isProxyArray(arguments[i])) {\n        length = arguments[i].length;\n        arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n      }\n    }\n\n    return prim_concat.apply(this, arguments);\n  }; // setPrototypeOf support on platforms that support __proto__\n\n\n  var prim_setPrototypeOf = Object.setPrototypeOf; // patch and extract original __proto__ setter\n\n  var __proto__setter = function () {\n    var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype, '__proto__');\n\n    if (protoDesc === undefined || typeof protoDesc.set !== \"function\") {\n      return function () {\n        throw new TypeError(\"setPrototypeOf not supported on this platform\");\n      };\n    } // see if we can actually mutate a prototype with the generic setter\n    // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n\n\n    try {\n      protoDesc.set.call({}, {});\n    } catch (e) {\n      return function () {\n        throw new TypeError(\"setPrototypeOf not supported on this platform\");\n      };\n    }\n\n    prim_defineProperty(Object.prototype, '__proto__', {\n      set: function (newProto) {\n        return Object.setPrototypeOf(this, Object(newProto));\n      }\n    });\n    return protoDesc.set;\n  }();\n\n  Object.setPrototypeOf = function (target, newProto) {\n    var handler = directProxies.get(target);\n\n    if (handler !== undefined) {\n      if (handler.setPrototypeOf(newProto)) {\n        return target;\n      } else {\n        throw new TypeError(\"proxy rejected prototype mutation\");\n      }\n    } else {\n      if (!Object_isExtensible(target)) {\n        throw new TypeError(\"can't set prototype on non-extensible object: \" + target);\n      }\n\n      if (prim_setPrototypeOf) return prim_setPrototypeOf(target, newProto);\n\n      if (Object(newProto) !== newProto || newProto === null) {\n        throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto); // throw new TypeError(\"prototype must be an object or null\")\n      }\n\n      __proto__setter.call(target, newProto);\n\n      return target;\n    }\n  };\n\n  Object.prototype.hasOwnProperty = function (name) {\n    var handler = safeWeakMapGet(directProxies, this);\n\n    if (handler !== undefined) {\n      var desc = handler.getOwnPropertyDescriptor(name);\n      return desc !== undefined;\n    } else {\n      return prim_hasOwnProperty.call(this, name);\n    }\n  }; // ============= Reflection module =============\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\n\n  var Reflect = {\n    getOwnPropertyDescriptor: function (target, name) {\n      return Object.getOwnPropertyDescriptor(target, name);\n    },\n    defineProperty: function (target, name, desc) {\n      // if target is a proxy, invoke its \"defineProperty\" trap\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.defineProperty(target, name, desc);\n      } // Implementation transliterated from [[DefineOwnProperty]]\n      // see ES5.1 section 8.12.9\n      // this is the _exact same algorithm_ as the isCompatibleDescriptor\n      // algorithm defined above, except that at every place it\n      // returns true, this algorithm actually does define the property.\n\n\n      var current = Object.getOwnPropertyDescriptor(target, name);\n      var extensible = Object.isExtensible(target);\n\n      if (current === undefined && extensible === false) {\n        return false;\n      }\n\n      if (current === undefined && extensible === true) {\n        Object.defineProperty(target, name, desc); // should never fail\n\n        return true;\n      }\n\n      if (isEmptyDescriptor(desc)) {\n        return true;\n      }\n\n      if (isEquivalentDescriptor(current, desc)) {\n        return true;\n      }\n\n      if (current.configurable === false) {\n        if (desc.configurable === true) {\n          return false;\n        }\n\n        if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n          return false;\n        }\n      }\n\n      if (isGenericDescriptor(desc)) {// no further validation necessary\n      } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n        if (current.configurable === false) {\n          return false;\n        }\n      } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n        if (current.configurable === false) {\n          if (current.writable === false && desc.writable === true) {\n            return false;\n          }\n\n          if (current.writable === false) {\n            if ('value' in desc && !sameValue(desc.value, current.value)) {\n              return false;\n            }\n          }\n        }\n      } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n        if (current.configurable === false) {\n          if ('set' in desc && !sameValue(desc.set, current.set)) {\n            return false;\n          }\n\n          if ('get' in desc && !sameValue(desc.get, current.get)) {\n            return false;\n          }\n        }\n      }\n\n      Object.defineProperty(target, name, desc); // should never fail\n\n      return true;\n    },\n    deleteProperty: function (target, name) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.delete(name);\n      }\n\n      var desc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (desc === undefined) {\n        return true;\n      }\n\n      if (desc.configurable === true) {\n        delete target[name];\n        return true;\n      }\n\n      return false;\n    },\n    getPrototypeOf: function (target) {\n      return Object.getPrototypeOf(target);\n    },\n    setPrototypeOf: function (target, newProto) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.setPrototypeOf(newProto);\n      }\n\n      if (Object(newProto) !== newProto || newProto === null) {\n        throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto);\n      }\n\n      if (!Object_isExtensible(target)) {\n        return false;\n      }\n\n      var current = Object.getPrototypeOf(target);\n\n      if (sameValue(current, newProto)) {\n        return true;\n      }\n\n      if (prim_setPrototypeOf) {\n        try {\n          prim_setPrototypeOf(target, newProto);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      __proto__setter.call(target, newProto);\n\n      return true;\n    },\n    preventExtensions: function (target) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.preventExtensions();\n      }\n\n      prim_preventExtensions(target);\n      return true;\n    },\n    isExtensible: function (target) {\n      return Object.isExtensible(target);\n    },\n    has: function (target, name) {\n      return name in target;\n    },\n    get: function (target, name, receiver) {\n      receiver = receiver || target; // if target is a proxy, invoke its \"get\" trap\n\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.get(receiver, name);\n      }\n\n      var desc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (desc === undefined) {\n        var proto = Object.getPrototypeOf(target);\n\n        if (proto === null) {\n          return undefined;\n        }\n\n        return Reflect.get(proto, name, receiver);\n      }\n\n      if (isDataDescriptor(desc)) {\n        return desc.value;\n      }\n\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return desc.get.call(receiver);\n    },\n    // Reflect.set implementation based on latest version of [[SetP]] at\n    // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n    set: function (target, name, value, receiver) {\n      receiver = receiver || target; // if target is a proxy, invoke its \"set\" trap\n\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.set(receiver, name, value);\n      } // first, check whether target has a non-writable property\n      // shadowing name on receiver\n\n\n      var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (ownDesc === undefined) {\n        // name is not defined in target, search target's prototype\n        var proto = Object.getPrototypeOf(target);\n\n        if (proto !== null) {\n          // continue the search in target's prototype\n          return Reflect.set(proto, name, value, receiver);\n        } // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n        // target was the last prototype, now we know that 'name' is not shadowed\n        // by an existing (accessor or data) property, so we can add the property\n        // to the initial receiver object\n        // (this branch will intentionally fall through to the code below)\n\n\n        ownDesc = {\n          value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n      } // we now know that ownDesc !== undefined\n\n\n      if (isAccessorDescriptor(ownDesc)) {\n        var setter = ownDesc.set;\n        if (setter === undefined) return false;\n        setter.call(receiver, value); // assumes Function.prototype.call\n\n        return true;\n      } // otherwise, isDataDescriptor(ownDesc) must be true\n\n\n      if (ownDesc.writable === false) return false; // we found an existing writable data property on the prototype chain.\n      // Now update or add the data property on the receiver, depending on\n      // whether the receiver already defines the property or not.\n\n      var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n\n      if (existingDesc !== undefined) {\n        var updateDesc = {\n          value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable: existingDesc.writable,\n          enumerable: existingDesc.enumerable,\n          configurable: existingDesc.configurable\n        };\n        Object.defineProperty(receiver, name, updateDesc);\n        return true;\n      } else {\n        if (!Object.isExtensible(receiver)) return false;\n        var newDesc = {\n          value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n        Object.defineProperty(receiver, name, newDesc);\n        return true;\n      }\n    },\n\n    /*invoke: function(target, name, args, receiver) {\n      receiver = receiver || target;\n       var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.invoke(receiver, name, args);\n      }\n       var fun = Reflect.get(target, name, receiver);\n      return Function.prototype.apply.call(fun, receiver, args);\n    },*/\n    enumerate: function (target) {\n      var handler = directProxies.get(target);\n      var result;\n\n      if (handler !== undefined) {\n        // handler.enumerate should return an iterator directly, but the\n        // iterator gets converted to an array for backward-compat reasons,\n        // so we must re-iterate over the array\n        result = handler.enumerate(handler.target);\n      } else {\n        result = [];\n\n        for (var name in target) {\n          result.push(name);\n        }\n\n        ;\n      }\n\n      var l = +result.length;\n      var idx = 0;\n      return {\n        next: function () {\n          if (idx === l) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: result[idx++]\n          };\n        }\n      };\n    },\n    // imperfect ownKeys implementation: in ES6, should also include\n    // symbol-keyed properties.\n    ownKeys: function (target) {\n      return Object_getOwnPropertyNames(target);\n    },\n    apply: function (target, receiver, args) {\n      // target.apply(receiver, args)\n      return Function.prototype.apply.call(target, receiver, args);\n    },\n    construct: function (target, args, newTarget) {\n      // return new target(...args);\n      // if target is a proxy, invoke its \"construct\" trap\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.construct(handler.target, args, newTarget);\n      }\n\n      if (typeof target !== \"function\") {\n        throw new TypeError(\"target is not a function: \" + target);\n      }\n\n      if (newTarget === undefined || newTarget === target) {\n        // If newTarget is undefined, then newTarget is set to `target` and\n        // `Reflect.construct(target, ...args)` becomes equivalent to\n        // `new target(...args)`\n        // if `target` is an ES2015 Class constructor, it must be called using\n        // the `new` operator. Hence we use the new operator on a bound function\n        // to trigger the [[Construct]] internal method. This technique will work \n        // for both plain constructor functions and ES2015 classes\n        return new (Function.prototype.bind.apply(target, [null].concat(args)))();\n      } else {\n        if (typeof newTarget !== \"function\") {\n          throw new TypeError(\"newTarget is not a function: \" + target);\n        } // if newTarget is a *different* constructor function, we need to\n        // emulate [[Construct]] by falling back to [[Call]] with a hand-crafted\n        // new instance inheriting from newTarget.prototype\n        // Unfortunately this won't work if target is an ES2015 Constructor\n        // function, whose [[Call]] method throws an error (it must be invoked\n        // using the `new` operator)\n\n\n        var proto = newTarget.prototype;\n        var instance = Object(proto) === proto ? Object.create(proto) : {};\n        var result = Function.prototype.apply.call(target, instance, args);\n        return Object(result) === result ? result : instance;\n      }\n    }\n  }; // feature-test whether the Reflect global exists\n\n  if (global.Reflect !== undefined) {\n    // Reflect exists, add/override the shimmed methods\n    Object.getOwnPropertyNames(Reflect).forEach(function (key) {\n      global.Reflect[key] = Reflect[key];\n    });\n  } else {\n    // Reflect doesn't exist, define it as the shimmed Reflect object\n    global.Reflect = Reflect;\n  } // feature-test whether the Proxy global exists, with\n  // the harmony-era Proxy.create API\n\n\n  if (typeof Proxy !== \"undefined\" && typeof Proxy.create !== \"undefined\") {\n    var primCreate = Proxy.create,\n        primCreateFunction = Proxy.createFunction;\n    var revokedHandler = primCreate({\n      get: function () {\n        throw new TypeError(\"proxy is revoked\");\n      }\n    });\n\n    global.Proxy = function (target, handler) {\n      // check that target is an Object\n      if (Object(target) !== target) {\n        throw new TypeError(\"Proxy target must be an Object, given \" + target);\n      } // check that handler is an Object\n\n\n      if (Object(handler) !== handler) {\n        throw new TypeError(\"Proxy handler must be an Object, given \" + handler);\n      }\n\n      var vHandler = new Validator(target, handler);\n      var proxy;\n\n      if (typeof target === \"function\") {\n        proxy = primCreateFunction(vHandler, // call trap\n        function () {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        }, // construct trap\n        function () {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n      } else {\n        proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n      }\n\n      directProxies.set(proxy, vHandler);\n      return proxy;\n    };\n\n    global.Proxy.revocable = function (target, handler) {\n      var proxy = new Proxy(target, handler);\n\n      var revoke = function () {\n        var vHandler = directProxies.get(proxy);\n\n        if (vHandler !== null) {\n          vHandler.target = null;\n          vHandler.handler = revokedHandler;\n        }\n\n        return undefined;\n      };\n\n      return {\n        proxy: proxy,\n        revoke: revoke\n      };\n    }; // add the old Proxy.create and Proxy.createFunction methods\n    // so old code that still depends on the harmony-era Proxy object\n    // is not broken. Also ensures that multiple versions of this\n    // library should load fine\n\n\n    global.Proxy.create = primCreate;\n    global.Proxy.createFunction = primCreateFunction;\n  } else {\n    // Proxy global not defined, or old API not available\n    if (typeof Proxy === \"undefined\") {\n      // Proxy global not defined, add a Proxy function stub\n      global.Proxy = function (_target, _handler) {\n        throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n      };\n    } // Proxy global defined but old API not available\n    // presumably Proxy global already supports new API, leave untouched\n\n  } // for node.js modules, export every property in the Reflect object\n  // as part of the module interface\n\n\n  if (typeof exports !== 'undefined') {\n    Object.keys(Reflect).forEach(function (key) {\n      exports[key] = Reflect[key];\n    });\n  } // function-as-module pattern\n\n})(typeof exports !== 'undefined' ? global : this);","map":{"version":3,"sources":["/home/rajesh/my_files/web/react/course_content/react-complete-guide-code-03-react-basics-working-with-components/code/02-building-a-first-custom-component/node_modules/harmony-reflect/reflect.js"],"names":["global","WeakMap","prototype","get","k","undefined","set","v","Error","isStandardAttribute","name","test","toPropertyDescriptor","obj","Object","TypeError","desc","enumerable","configurable","value","writable","getter","setter","isAccessorDescriptor","isDataDescriptor","isGenericDescriptor","toCompletePropertyDescriptor","internalDesc","isEmptyDescriptor","isEquivalentDescriptor","desc1","desc2","sameValue","x","y","normalizeAndCompletePropertyDescriptor","attributes","defineProperty","normalizePropertyDescriptor","prim_preventExtensions","preventExtensions","prim_seal","seal","prim_freeze","freeze","prim_isExtensible","isExtensible","prim_isSealed","isSealed","prim_isFrozen","isFrozen","prim_getPrototypeOf","getPrototypeOf","prim_getOwnPropertyDescriptor","getOwnPropertyDescriptor","prim_defineProperty","prim_defineProperties","defineProperties","prim_keys","keys","prim_getOwnPropertyNames","getOwnPropertyNames","prim_getOwnPropertySymbols","getOwnPropertySymbols","prim_assign","assign","prim_isArray","Array","isArray","prim_concat","concat","prim_isPrototypeOf","isPrototypeOf","prim_hasOwnProperty","hasOwnProperty","Object_isFrozen","Object_isSealed","Object_isExtensible","Object_getPrototypeOf","Object_getOwnPropertyNames","isFixed","target","call","isSealedDesc","isCompatibleDescriptor","extensible","current","setIntegrityLevel","level","ownProps","pendingException","l","length","i","String","e","currentDesc","Reflect","testIntegrityLevel","Validator","handler","getTrap","trapName","trap","targetDesc","getPropertyDescriptor","has","val","descObj","success","delete","deleteProperty","res","ownKeys","trapResult","propNames","create","numProps","result","s","forEach","ownProp","state","allegedProto","actualProto","setPrototypeOf","newProto","getPropertyNames","receiver","fixedDesc","enumerate","nxt","next","done","push","ownEnumerableProps","ownEnumerableProp","iterate","apply","thisBinding","args","construct","newTarget","directProxies","subject","vhandler","vHandler","normalizedDesc","descs","names","noProxies","arguments","output","index","source","nextKey","isObject","arg","type","safeWeakMapGet","map","key","makeUnwrapping0ArgMethod","primitive","builtin","makeUnwrapping1ArgMethod","valueOf","toString","Function","Date","vHandler2","isProxyArray","slice","prim_setPrototypeOf","__proto__setter","protoDesc","proto","ownDesc","existingDesc","updateDesc","newDesc","idx","bind","instance","Proxy","primCreate","primCreateFunction","createFunction","revokedHandler","proxy","revocable","revoke","_target","_handler","exports"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEC;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACD;AACC;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA,WAASA,MAAT,EAAgB;AAAE;AACnB,eADiB,CAGjB;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;;AACA,MAAI,OAAOC,OAAP,KAAmB,WAAvB,EAAoC;AAClCD,IAAAA,MAAM,CAACC,OAAP,GAAiB,YAAU,CAAE,CAA7B;;AACAD,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,GAA2B;AACzBC,MAAAA,GAAG,EAAE,UAASC,CAAT,EAAY;AAAE,eAAOC,SAAP;AAAmB,OADb;AAEzBC,MAAAA,GAAG,EAAE,UAASF,CAAT,EAAWG,CAAX,EAAc;AAAE,cAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;AAA2C;AAFvC,KAA3B;AAID,GAxGgB,CA0GjB;;;AAEA,WAASC,mBAAT,CAA6BC,IAA7B,EAAmC;AACjC,WAA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A;AACA;AACA;AACA;AACA;AACA;;;AAGI,UAAIG,kBAAkB,GAAGzH,MAAM,CAAC6C,IAAP,CAAY,KAAKsB,MAAjB,CAAzB;AACA,UAAIA,MAAM,GAAG,KAAKA,MAAlB;AACAsD,MAAAA,kBAAkB,CAACf,OAAnB,CAA2B,UAAUgB,iBAAV,EAA6B;AACtD,YAAI,CAACrB,SAAS,CAACqB,iBAAD,CAAd,EAAmC;AACjC,cAAIxF,QAAQ,CAACwF,iBAAD,EAAoBvD,MAApB,CAAZ,EAAyC;AACvC,kBAAM,IAAIlE,SAAJ,CAAc,sCACA,wCADA,GAEAyH,iBAFA,GAEkB,GAFhC,CAAN;AAGD;;AACD,cAAI,CAAC1H,MAAM,CAACgC,YAAP,CAAoBmC,MAApB,CAAD,IACAD,OAAO,CAACwD,iBAAD,EAAoBvD,MAApB,CADX,EACwC;AACpC;AACA;AACA;AACA;AACA;AACA,kBAAM,IAAIlE,SAAJ,CAAc,0CACAyH,iBADA,GACkB,yBADlB,GAEA,uBAFd,CAAN;AAGH;AACF;AACF,OAnBD;AAqBA,aAAOlB,MAAP;AACD,KApsBmB;;AAssBpB;AACF;AACA;AACEmB,IAAAA,OAAO,EAAEtC,SAAS,CAACjG,SAAV,CAAoBgI,SAzsBT;;AA2sBpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAQE;AACF;AACA;AACA;AACA;AACA;AACEQ,IAAAA,KAAK,EAAE,UAASzD,MAAT,EAAiB0D,WAAjB,EAA8BC,IAA9B,EAAoC;AACzC,UAAIrC,IAAI,GAAG,KAAKF,OAAL,CAAa,OAAb,CAAX;;AACA,UAAIE,IAAI,KAAKlG,SAAb,EA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","sourcesContent":["// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n\n // ----------------------------------------------------------------------------\n\n // This file is a polyfill for the upcoming ECMAScript Reflect API,\n // including support for Proxies. See the draft specification at:\n // http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n // For an implementation of the Handler API, see handlers.js, which implements:\n // http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n\n // This implementation supersedes the earlier polyfill at:\n // code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n\n // This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n // The code also works correctly on\n //   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n\n // Language Dependencies:\n //  - ECMAScript 5/strict\n //  - \"old\" (i.e. non-direct) Harmony Proxies\n //  - Harmony WeakMaps\n // Patches:\n //  - Object.{freeze,seal,preventExtensions}\n //  - Object.{isFrozen,isSealed,isExtensible}\n //  - Object.getPrototypeOf\n //  - Object.keys\n //  - Object.prototype.valueOf\n //  - Object.prototype.isPrototypeOf\n //  - Object.prototype.toString\n //  - Object.prototype.hasOwnProperty\n //  - Object.getOwnPropertyDescriptor\n //  - Object.defineProperty\n //  - Object.defineProperties\n //  - Object.getOwnPropertyNames\n //  - Object.getOwnPropertySymbols\n //  - Object.getPrototypeOf\n //  - Object.setPrototypeOf\n //  - Object.assign\n //  - Function.prototype.toString\n //  - Date.prototype.toString\n //  - Array.isArray\n //  - Array.prototype.concat\n //  - Proxy\n // Adds new globals:\n //  - Reflect\n\n // Direct proxies can be created via Proxy(target, handler)\n\n // ----------------------------------------------------------------------------\n\n(function(global){ // function-as-module pattern\n\"use strict\";\n\n// === Direct Proxies: Invariant Enforcement ===\n\n// Direct proxies build on non-direct proxies by automatically wrapping\n// all user-defined proxy handlers in a Validator handler that checks and\n// enforces ES5 invariants.\n\n// A direct proxy is a proxy for an existing object called the target object.\n\n// A Validator handler is a wrapper for a target proxy handler H.\n// The Validator forwards all operations to H, but additionally\n// performs a number of integrity checks on the results of some traps,\n// to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n// properties and non-extensible, sealed or frozen objects.\n\n// For each property that H exposes as own, non-configurable\n// (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n// the Validator handler defines those properties on the target object.\n// When the proxy becomes non-extensible, also configurable own properties\n// are checked against the target.\n// We will call properties that are defined on the target object\n// \"fixed properties\".\n\n// We will name fixed non-configurable properties \"sealed properties\".\n// We will name fixed non-configurable non-writable properties \"frozen\n// properties\".\n\n// The Validator handler upholds the following invariants w.r.t. non-configurability:\n// - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n// - getOwnPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property (e.g. reporting a non-configurable\n//   property as configurable, or reporting a non-configurable, non-writable\n//   property as writable)\n// - getPropertyDescriptor cannot report sealed properties as non-existent\n// - getPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property. It _can_ report incompatible changes\n//   to the attributes of non-own, inherited properties.\n// - defineProperty cannot make incompatible changes to the attributes of\n//   sealed properties\n// - deleteProperty cannot report a successful deletion of a sealed property\n// - hasOwn cannot report a sealed property as non-existent\n// - has cannot report a sealed property as non-existent\n// - get cannot report inconsistent values for frozen data\n//   properties, and must report undefined for sealed accessors with an\n//   undefined getter\n// - set cannot report a successful assignment for frozen data\n//   properties or sealed accessors with an undefined setter.\n// - get{Own}PropertyNames lists all sealed properties of the target.\n// - keys lists all enumerable sealed properties of the target.\n// - enumerate lists all enumerable sealed properties of the target.\n// - if a property of a non-extensible proxy is reported as non-existent,\n//   then it must forever be reported as non-existent. This applies to\n//   own and inherited properties and is enforced in the\n//   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n//   get{Own}PropertyNames, keys and enumerate traps\n\n// Violation of any of these invariants by H will result in TypeError being\n// thrown.\n\n// Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n// is invoked on the proxy, the set of own property names for the proxy is\n// fixed. Any property name that is not fixed is called a 'new' property.\n\n// The Validator upholds the following invariants regarding extensibility:\n// - getOwnPropertyDescriptor cannot report new properties as existent\n//   (it must report them as non-existent by returning undefined)\n// - defineProperty cannot successfully add a new property (it must reject)\n// - getOwnPropertyNames cannot list new properties\n// - hasOwn cannot report true for new properties (it must report false)\n// - keys cannot list new properties\n\n// Invariants currently not enforced:\n// - getOwnPropertyNames lists only own property names\n// - keys lists only enumerable own property names\n// Both traps may list more property names than are actually defined on the\n// target.\n\n// Invariants with regard to inheritance are currently not enforced.\n// - a non-configurable potentially inherited property on a proxy with\n//   non-mutable ancestry cannot be reported as non-existent\n// (An object with non-mutable ancestry is a non-extensible object whose\n// [[Prototype]] is either null or an object with non-mutable ancestry.)\n\n// Changes in Handler API compared to previous harmony:proxies, see:\n// http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// ----------------------------------------------------------------------------\n\n// ---- WeakMap polyfill ----\n\n// TODO: find a proper WeakMap polyfill\n\n// define an empty WeakMap so that at least the Reflect module code\n// will work in the absence of WeakMaps. Proxy emulation depends on\n// actual WeakMaps, so will not work with this little shim.\nif (typeof WeakMap === \"undefined\") {\n  global.WeakMap = function(){};\n  global.WeakMap.prototype = {\n    get: function(k) { return undefined; },\n    set: function(k,v) { throw new Error(\"WeakMap not supported\"); }\n  };\n}\n\n// ---- Normalization functions for property descriptors ----\n\nfunction isStandardAttribute(name) {\n  return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n}\n\n// Adapted from ES5 section 8.10.5\nfunction toPropertyDescriptor(obj) {\n  if (Object(obj) !== obj) {\n    throw new TypeError(\"property descriptor should be an Object, given: \"+\n                        obj);\n  }\n  var desc = {};\n  if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n  if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n  if ('value' in obj) { desc.value = obj.value; }\n  if ('writable' in obj) { desc.writable = !!obj.writable; }\n  if ('get' in obj) {\n    var getter = obj.get;\n    if (getter !== undefined && typeof getter !== \"function\") {\n      throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                          \"callable or undefined, given: \"+getter);\n    }\n    desc.get = getter;\n  }\n  if ('set' in obj) {\n    var setter = obj.set;\n    if (setter !== undefined && typeof setter !== \"function\") {\n      throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                          \"callable or undefined, given: \"+setter);\n    }\n    desc.set = setter;\n  }\n  if ('get' in desc || 'set' in desc) {\n    if ('value' in desc || 'writable' in desc) {\n      throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                          \"accessor descriptor: \"+obj);\n    }\n  }\n  return desc;\n}\n\nfunction isAccessorDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('get' in desc || 'set' in desc);\n}\nfunction isDataDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('value' in desc || 'writable' in desc);\n}\nfunction isGenericDescriptor(desc) {\n  if (desc === undefined) return false;\n  return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n}\n\nfunction toCompletePropertyDescriptor(desc) {\n  var internalDesc = toPropertyDescriptor(desc);\n  if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n    if (!('value' in internalDesc)) { internalDesc.value = undefined; }\n    if (!('writable' in internalDesc)) { internalDesc.writable = false; }\n  } else {\n    if (!('get' in internalDesc)) { internalDesc.get = undefined; }\n    if (!('set' in internalDesc)) { internalDesc.set = undefined; }\n  }\n  if (!('enumerable' in internalDesc)) { internalDesc.enumerable = false; }\n  if (!('configurable' in internalDesc)) { internalDesc.configurable = false; }\n  return internalDesc;\n}\n\nfunction isEmptyDescriptor(desc) {\n  return !('get' in desc) &&\n         !('set' in desc) &&\n         !('value' in desc) &&\n         !('writable' in desc) &&\n         !('enumerable' in desc) &&\n         !('configurable' in desc);\n}\n\nfunction isEquivalentDescriptor(desc1, desc2) {\n  return sameValue(desc1.get, desc2.get) &&\n         sameValue(desc1.set, desc2.set) &&\n         sameValue(desc1.value, desc2.value) &&\n         sameValue(desc1.writable, desc2.writable) &&\n         sameValue(desc1.enumerable, desc2.enumerable) &&\n         sameValue(desc1.configurable, desc2.configurable);\n}\n\n// copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\nfunction sameValue(x, y) {\n  if (x === y) {\n    // 0 === -0, but they are not identical\n    return x !== 0 || 1 / x === 1 / y;\n  }\n\n  // NaN !== NaN, but they are identical.\n  // NaNs are the only non-reflexive value, i.e., if x !== x,\n  // then x is a NaN.\n  // isNaN is broken: it converts its argument to number, so\n  // isNaN(\"foo\") => true\n  return x !== x && y !== y;\n}\n\n/**\n * Returns a fresh property descriptor that is guaranteed\n * to be complete (i.e. contain all the standard attributes).\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, returns undefined.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizeAndCompletePropertyDescriptor(attributes) {\n  if (attributes === undefined) { return undefined; }\n  var desc = toCompletePropertyDescriptor(attributes);\n  // Note: no need to call FromPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n/**\n * Returns a fresh property descriptor whose standard\n * attributes are guaranteed to be data properties of the right type.\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, will throw a TypeError.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizePropertyDescriptor(attributes) {\n  var desc = toPropertyDescriptor(attributes);\n  // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n// store a reference to the real ES5 primitives before patching them later\nvar prim_preventExtensions =        Object.preventExtensions,\n    prim_seal =                     Object.seal,\n    prim_freeze =                   Object.freeze,\n    prim_isExtensible =             Object.isExtensible,\n    prim_isSealed =                 Object.isSealed,\n    prim_isFrozen =                 Object.isFrozen,\n    prim_getPrototypeOf =           Object.getPrototypeOf,\n    prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    prim_defineProperty =           Object.defineProperty,\n    prim_defineProperties =         Object.defineProperties,\n    prim_keys =                     Object.keys,\n    prim_getOwnPropertyNames =      Object.getOwnPropertyNames,\n    prim_getOwnPropertySymbols =    Object.getOwnPropertySymbols,\n    prim_assign =                   Object.assign,\n    prim_isArray =                  Array.isArray,\n    prim_concat =                   Array.prototype.concat,\n    prim_isPrototypeOf =            Object.prototype.isPrototypeOf,\n    prim_hasOwnProperty =           Object.prototype.hasOwnProperty;\n\n// these will point to the patched versions of the respective methods on\n// Object. They are used within this module as the \"intrinsic\" bindings\n// of these methods (i.e. the \"original\" bindings as defined in the spec)\nvar Object_isFrozen,\n    Object_isSealed,\n    Object_isExtensible,\n    Object_getPrototypeOf,\n    Object_getOwnPropertyNames;\n\n/**\n * A property 'name' is fixed if it is an own property of the target.\n */\nfunction isFixed(name, target) {\n  return ({}).hasOwnProperty.call(target, name);\n}\nfunction isSealed(name, target) {\n  var desc = Object.getOwnPropertyDescriptor(target, name);\n  if (desc === undefined) { return false; }\n  return desc.configurable === false;\n}\nfunction isSealedDesc(desc) {\n  return desc !== undefined && desc.configurable === false;\n}\n\n/**\n * Performs all validation that Object.defineProperty performs,\n * without actually defining the property. Returns a boolean\n * indicating whether validation succeeded.\n *\n * Implementation transliterated from ES5.1 section 8.12.9\n */\nfunction isCompatibleDescriptor(extensible, current, desc) {\n  if (current === undefined && extensible === false) {\n    return false;\n  }\n  if (current === undefined && extensible === true) {\n    return true;\n  }\n  if (isEmptyDescriptor(desc)) {\n    return true;\n  }\n  if (isEquivalentDescriptor(current, desc)) {\n    return true;\n  }\n  if (current.configurable === false) {\n    if (desc.configurable === true) {\n      return false;\n    }\n    if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n      return false;\n    }\n  }\n  if (isGenericDescriptor(desc)) {\n    return true;\n  }\n  if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      return false;\n    }\n    return true;\n  }\n  if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      if (current.writable === false && desc.writable === true) {\n        return false;\n      }\n      if (current.writable === false) {\n        if ('value' in desc && !sameValue(desc.value, current.value)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n    if (current.configurable === false) {\n      if ('set' in desc && !sameValue(desc.set, current.set)) {\n        return false;\n      }\n      if ('get' in desc && !sameValue(desc.get, current.get)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// ES6 7.3.11 SetIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction setIntegrityLevel(target, level) {\n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  if (level === \"sealed\") {\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        Object.defineProperty(target, k, { configurable: false });\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  } else {\n    // level === \"frozen\"\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        if (currentDesc !== undefined) {\n          var desc;\n          if (isAccessorDescriptor(currentDesc)) {\n            desc = { configurable: false }\n          } else {\n            desc = { configurable: false, writable: false }\n          }\n          Object.defineProperty(target, k, desc);\n        }        \n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  return Reflect.preventExtensions(target);\n}\n\n// ES6 7.3.12 TestIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction testIntegrityLevel(target, level) {\n  var isExtensible = Object_isExtensible(target);\n  if (isExtensible) return false;\n  \n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  var configurable = false;\n  var writable = false;\n  \n  var l = +ownProps.length;\n  var k;\n  var currentDesc;\n  for (var i = 0; i < l; i++) {\n    k = String(ownProps[i]);\n    try {\n      currentDesc = Object.getOwnPropertyDescriptor(target, k);\n      configurable = configurable || currentDesc.configurable;\n      if (isDataDescriptor(currentDesc)) {\n        writable = writable || currentDesc.writable;\n      }\n    } catch (e) {\n      if (pendingException === undefined) {\n        pendingException = e;\n        configurable = true;\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  if (level === \"frozen\" && writable === true) {\n    return false;\n  }\n  if (configurable === true) {\n    return false;\n  }\n  return true;\n}\n\n// ---- The Validator handler wrapper around user handlers ----\n\n/**\n * @param target the object wrapped by this proxy.\n * As long as the proxy is extensible, only non-configurable properties\n * are checked against the target. Once the proxy becomes non-extensible,\n * invariants w.r.t. non-extensibility are also enforced.\n *\n * @param handler the handler of the direct proxy. The object emulated by\n * this handler is validated against the target object of the direct proxy.\n * Any violations that the handler makes against the invariants\n * of the target will cause a TypeError to be thrown.\n *\n * Both target and handler must be proper Objects at initialization time.\n */\nfunction Validator(target, handler) {\n  // for non-revokable proxies, these are const references\n  // for revokable proxies, on revocation:\n  // - this.target is set to null\n  // - this.handler is set to a handler that throws on all traps\n  this.target  = target;\n  this.handler = handler;\n}\n\nValidator.prototype = {\n\n  /**\n   * If getTrap returns undefined, the caller should perform the\n   * default forwarding behavior.\n   * If getTrap returns normally otherwise, the return value\n   * will be a callable trap function. When calling the trap function,\n   * the caller is responsible for binding its |this| to |this.handler|.\n   */\n  getTrap: function(trapName) {\n    var trap = this.handler[trapName];\n    if (trap === undefined) {\n      // the trap was not defined,\n      // perform the default forwarding behavior\n      return undefined;\n    }\n\n    if (typeof trap !== \"function\") {\n      throw new TypeError(trapName + \" trap is not callable: \"+trap);\n    }\n\n    return trap;\n  },\n\n  // === fundamental traps ===\n\n  /**\n   * If name denotes a fixed property, check:\n   *   - whether targetHandler reports it as existent\n   *   - whether the returned descriptor is compatible with the fixed property\n   * If the proxy is non-extensible, check:\n   *   - whether name is not a new property\n   * Additionally, the returned descriptor is normalized and completed.\n   */\n  getOwnPropertyDescriptor: function(name) {\n    \"use strict\";\n\n    var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n    if (trap === undefined) {\n      return Reflect.getOwnPropertyDescriptor(this.target, name);\n    }\n\n    name = String(name);\n    var desc = trap.call(this.handler, this.target, name);\n    desc = normalizeAndCompletePropertyDescriptor(desc);\n\n    var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    var extensible = Object.isExtensible(this.target);\n\n    if (desc === undefined) {\n      if (isSealedDesc(targetDesc)) {\n        throw new TypeError(\"cannot report non-configurable property '\"+name+\n                            \"' as non-existent\");\n      }\n      if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n      return undefined;\n    }\n\n    // at this point, we know (desc !== undefined), i.e.\n    // targetHandler reports 'name' as an existing property\n\n    // Note: we could collapse the following two if-tests into a single\n    // test. Separating out the cases to improve error reporting.\n\n    if (!extensible) {\n      if (targetDesc === undefined) {\n        throw new TypeError(\"cannot report a new own property '\"+\n                            name + \"' on a non-extensible object\");\n      }\n    }\n\n    if (name !== undefined) {\n      if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n        throw new TypeError(\"cannot report incompatible property descriptor \"+\n                            \"for property '\"+name+\"'\");\n      }\n    }\n    \n    if (desc.configurable === false) {\n      if (targetDesc === undefined || targetDesc.configurable === true) {\n        // if the property is configurable or non-existent on the target,\n        // but is reported as a non-configurable property, it may later be\n        // reported as configurable or non-existent, which violates the\n        // invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot report a non-configurable descriptor \" +\n          \"for configurable or non-existent property '\" + name + \"'\");\n      }\n      if ('writable' in desc && desc.writable === false) {\n        if (targetDesc.writable === true) {\n          // if the property is non-configurable, writable on the target,\n          // but is reported as non-configurable, non-writable, it may later\n          // be reported as non-configurable, writable again, which violates\n          // the invariant that a non-configurable, non-writable property\n          // may not change state.\n          throw new TypeError(\n            \"cannot report non-configurable, writable property '\" + name +\n            \"' as non-configurable, non-writable\");\n        }\n      }\n    }\n\n    return desc;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, instead\n   * of calling this trap, the get, set, has or enumerate traps are\n   * called instead.\n   *\n   * In this implementation, we \"abuse\" getPropertyDescriptor to\n   * support trapping the get or set traps for proxies-as-prototypes.\n   * We do this by returning a getter/setter pair that invokes\n   * the corresponding traps.\n   *\n   * While this hack works for inherited property access, it has some\n   * quirks:\n   *\n   * In Firefox, this trap is only called after a prior invocation\n   * of the 'has' trap has returned true. Hence, expect the following\n   * behavior:\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * child[name] // triggers handler.has(target, name)\n   * // if that returns true, triggers handler.get(target, name, child)\n   * </code>\n   *\n   * On v8, the 'in' operator, when applied to an object that inherits\n   * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n   * That calls the below getPropertyDescriptor trap on the proxy. The\n   * result of the 'in'-operator is then determined by whether this trap\n   * returns undefined or a property descriptor object. That is why\n   * we first explicitly trigger the 'has' trap to determine whether\n   * the property exists.\n   *\n   * This has the side-effect that when enumerating properties on\n   * an object that inherits from a proxy in v8, only properties\n   * for which 'has' returns true are returned:\n   *\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * for (var prop in child) {\n   *   // only enumerates prop if (prop in child) returns true\n   * }\n   * </code>\n   */\n  getPropertyDescriptor: function(name) {\n    var handler = this;\n\n    if (!handler.has(name)) return undefined;\n\n    return {\n      get: function() {\n        return handler.get(this, name);\n      },\n      set: function(val) {\n        if (handler.set(this, name, val)) {\n          return val;\n        } else {\n          throw new TypeError(\"failed assignment to \"+name);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    };\n  },\n\n  /**\n   * If name denotes a fixed property, check for incompatible changes.\n   * If the proxy is non-extensible, check that new properties are rejected.\n   */\n  defineProperty: function(name, desc) {\n    // TODO(tvcutsem): the current tracemonkey implementation of proxies\n    // auto-completes 'desc', which is not correct. 'desc' should be\n    // normalized, but not completed. Consider:\n    // Object.defineProperty(proxy, 'foo', {enumerable:false})\n    // This trap will receive desc =\n    //  {value:undefined,writable:false,enumerable:false,configurable:false}\n    // This will also set all other attributes to their default value,\n    // which is unexpected and different from [[DefineOwnProperty]].\n    // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n\n    var trap = this.getTrap(\"defineProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.defineProperty(this.target, name, desc);\n    }\n\n    name = String(name);\n    var descObj = normalizePropertyDescriptor(desc);\n    var success = trap.call(this.handler, this.target, name, descObj);\n    success = !!success; // coerce to Boolean\n\n    if (success === true) {\n\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot successfully add a new property '\"+\n                              name + \"' to a non-extensible object\");\n        }\n      }\n\n      if (targetDesc !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot define incompatible property \"+\n                              \"descriptor for property '\"+name+\"'\");\n        }\n        if (isDataDescriptor(targetDesc) &&\n            targetDesc.configurable === false &&\n            targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\n                \"cannot successfully define non-configurable, writable \" +\n                \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n      }\n\n      if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n        // if the property is configurable or non-existent on the target,\n        // but is successfully being redefined as a non-configurable property,\n        // it may later be reported as configurable or non-existent, which violates\n        // the invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot successfully define a non-configurable \" +\n          \"descriptor for configurable or non-existent property '\" +\n          name + \"'\");\n      }\n\n    }\n\n    return success;\n  },\n\n  /**\n   * On success, check whether the target object is indeed non-extensible.\n   */\n  preventExtensions: function() {\n    var trap = this.getTrap(\"preventExtensions\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.preventExtensions(this.target);\n    }\n\n    var success = trap.call(this.handler, this.target);\n    success = !!success; // coerce to Boolean\n    if (success) {\n      if (Object_isExtensible(this.target)) {\n        throw new TypeError(\"can't report extensible object as non-extensible: \"+\n                            this.target);\n      }\n    }\n    return success;\n  },\n\n  /**\n   * If name denotes a sealed property, check whether handler rejects.\n   */\n  delete: function(name) {\n    \"use strict\";\n    var trap = this.getTrap(\"deleteProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.deleteProperty(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    var targetDesc;\n    if (res === true) {\n      targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (targetDesc !== undefined && targetDesc.configurable === false) {\n        throw new TypeError(\"property '\" + name + \"' is non-configurable \"+\n                            \"and can't be deleted\");\n      }\n      if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n        // if the property still exists on a non-extensible target but\n        // is reported as successfully deleted, it may later be reported\n        // as present, which violates the invariant that an own property,\n        // deleted from a non-extensible object cannot reappear.\n        throw new TypeError(\n          \"cannot successfully delete existing property '\" + name +\n          \"' on a non-extensible object\");\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n   * which now also returns an array (of strings or symbols) and\n   * which performs the same rigorous invariant checks as getOwnPropertyNames\n   *\n   * See issue #48 on how this trap can still get invoked by external libs\n   * that don't use the patched Object.getOwnPropertyNames function.\n   */\n  getOwnPropertyNames: function() {\n    // Note: removed deprecation warning to avoid dependency on 'console'\n    // (and on node, should anyway use util.deprecate). Deprecation warnings\n    // can also be annoying when they are outside of the user's control, e.g.\n    // when an external library calls unpatched Object.getOwnPropertyNames.\n    // Since there is a clean fallback to `ownKeys`, the fact that the\n    // deprecated method is still called is mostly harmless anyway.\n    // See also issues #65 and #66.\n    // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n    return this.ownKeys();\n  },\n\n  /**\n   * Checks whether the trap result does not contain any new properties\n   * if the proxy is non-extensible.\n   *\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * Additionally, the trap result is normalized.\n   * Instead of returning the trap result directly:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to a String\n   *\n   * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n   * and Object.keys (the latter filters out only the enumerable own properties).\n   */\n  ownKeys: function() {\n    var trap = this.getTrap(\"ownKeys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.ownKeys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n        // non-extensible proxies don't tolerate new own property names\n        throw new TypeError(\"ownKeys trap cannot list a new \"+\n                            \"property '\"+s+\"' on a non-extensible object\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    }\n\n    var ownProps = Object_getOwnPropertyNames(this.target);\n    var target = this.target;\n    ownProps.forEach(function (ownProp) {\n      if (!propNames[ownProp]) {\n        if (isSealed(ownProp, target)) {\n          throw new TypeError(\"ownKeys trap failed to include \"+\n                              \"non-configurable property '\"+ownProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\"+\n                                ownProp+\"' as non-existent on a non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * Checks whether the trap result is consistent with the state of the\n   * wrapped target.\n   */\n  isExtensible: function() {\n    var trap = this.getTrap(\"isExtensible\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.isExtensible(this.target);\n    }\n\n    var result = trap.call(this.handler, this.target);\n    result = !!result; // coerce to Boolean\n    var state = Object_isExtensible(this.target);\n    if (result !== state) {\n      if (result) {\n        throw new TypeError(\"cannot report non-extensible object as extensible: \"+\n                             this.target);\n      } else {\n        throw new TypeError(\"cannot report extensible object as non-extensible: \"+\n                             this.target);\n      }\n    }\n    return state;\n  },\n\n  /**\n   * Check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  getPrototypeOf: function() {\n    var trap = this.getTrap(\"getPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.getPrototypeOf(this.target);\n    }\n\n    var allegedProto = trap.call(this.handler, this.target);\n\n    if (!Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(allegedProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return allegedProto;\n  },\n\n  /**\n   * If target is non-extensible and setPrototypeOf trap returns true,\n   * check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  setPrototypeOf: function(newProto) {\n    var trap = this.getTrap(\"setPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.setPrototypeOf(this.target, newProto);\n    }\n\n    var success = trap.call(this.handler, this.target, newProto);\n\n    success = !!success;\n    if (success && !Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(newProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return success;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, for-in will\n   * call the enumerate() trap. If that trap is not defined, the\n   * operation is forwarded to the target, no more fallback on this\n   * fundamental trap.\n   */\n  getPropertyNames: function() {\n    throw new TypeError(\"getPropertyNames trap is deprecated\");\n  },\n\n  // === derived traps ===\n\n  /**\n   * If name denotes a fixed property, check whether the trap returns true.\n   */\n  has: function(name) {\n    var trap = this.getTrap(\"has\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.has(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    if (res === false) {\n      if (isSealed(name, this.target)) {\n        throw new TypeError(\"cannot report existing non-configurable own \"+\n                            \"property '\"+ name + \"' as a non-existent \"+\n                            \"property\");\n      }\n      if (!Object.isExtensible(this.target) &&\n          isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n    }\n\n    // if res === true, we don't need to check for extensibility\n    // even for a non-extensible proxy that has no own name property,\n    // the property may have been inherited\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check its return value against the previously asserted value of the\n   * fixed property.\n   */\n  get: function(receiver, name) {\n\n    // experimental support for invoke() trap on platforms that\n    // support __noSuchMethod__\n    /*\n    if (name === '__noSuchMethod__') {\n      var handler = this;\n      return function(name, args) {\n        return handler.invoke(receiver, name, args);\n      }\n    }\n    */\n\n    var trap = this.getTrap(\"get\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.get(this.target, name, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, receiver);\n\n    var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    // check consistency of the returned value\n    if (fixedDesc !== undefined) { // getting an existing property\n      if (isDataDescriptor(fixedDesc) &&\n          fixedDesc.configurable === false &&\n          fixedDesc.writable === false) { // own frozen data property\n        if (!sameValue(res, fixedDesc.value)) {\n          throw new TypeError(\"cannot report inconsistent value for \"+\n                              \"non-writable, non-configurable property '\"+\n                              name+\"'\");\n        }\n      } else { // it's an accessor property\n        if (isAccessorDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.get === undefined) {\n          if (res !== undefined) {\n            throw new TypeError(\"must report undefined for non-configurable \"+\n                                \"accessor property '\"+name+\"' without getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check that the trap rejects the assignment.\n   */\n  set: function(receiver, name, val) {\n    var trap = this.getTrap(\"set\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.set(this.target, name, val, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, val, receiver);\n    res = !!res; // coerce to Boolean\n\n    // if success is reported, check whether property is truly assignable\n    if (res === true) {\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (fixedDesc !== undefined) { // setting an existing property\n        if (isDataDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.writable === false) {\n          if (!sameValue(val, fixedDesc.value)) {\n            throw new TypeError(\"cannot successfully assign to a \"+\n                                \"non-writable, non-configurable property '\"+\n                                name+\"'\");\n          }\n        } else {\n          if (isAccessorDescriptor(fixedDesc) &&\n              fixedDesc.configurable === false && // non-configurable\n              fixedDesc.set === undefined) {      // accessor with undefined setter\n            throw new TypeError(\"setting a property '\"+name+\"' that has \"+\n                                \" only a getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * Any own enumerable non-configurable properties of the target that are not\n   * included in the trap result give rise to a TypeError. As such, we check\n   * whether the returned result contains at least all sealed enumerable properties\n   * of the target object.\n   *\n   * The trap should return an iterator.\n   *\n   * However, as implementations of pre-direct proxies still expect enumerate\n   * to return an array of strings, we convert the iterator into an array.\n   */\n  enumerate: function() {\n    var trap = this.getTrap(\"enumerate\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      var trapResult = Reflect.enumerate(this.target);\n      var result = [];\n      var nxt = trapResult.next();\n      while (!nxt.done) {\n        result.push(String(nxt.value));\n        nxt = trapResult.next();\n      }\n      return result;\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n    \n    if (trapResult === null ||\n        trapResult === undefined ||\n        trapResult.next === undefined) {\n      throw new TypeError(\"enumerate trap should return an iterator, got: \"+\n                          trapResult);    \n    }\n    \n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    \n    // var numProps = +trapResult.length;\n    var result = []; // new Array(numProps);\n    \n    // trapResult is supposed to be an iterator\n    // drain iterator to array as current implementations still expect\n    // enumerate to return an array of strings\n    var nxt = trapResult.next();\n    \n    while (!nxt.done) {\n      var s = String(nxt.value);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n      propNames[s] = true;\n      result.push(s);\n      nxt = trapResult.next();\n    }\n    \n    /*for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    } */\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"enumerate trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * The iterate trap is deprecated by the enumerate trap.\n   */\n  iterate: Validator.prototype.enumerate,\n\n  /**\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * The trap result is normalized.\n   * The trap result is not returned directly. Instead:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to String,\n   *  - which does not contain duplicates\n   *\n   * FIXME: keys trap is deprecated\n   */\n  /*\n  keys: function() {\n    var trap = this.getTrap(\"keys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.keys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n     var s = String(trapResult[i]);\n     if (propNames[s]) {\n       throw new TypeError(\"keys trap cannot list a \"+\n                           \"duplicate property '\"+s+\"'\");\n     }\n     if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n       // non-extensible proxies don't tolerate new own property names\n       throw new TypeError(\"keys trap cannot list a new \"+\n                           \"property '\"+s+\"' on a non-extensible object\");\n     }\n\n     propNames[s] = true;\n     result[i] = s;\n    }\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"keys trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n  */\n  \n  /**\n   * New trap that reifies [[Call]].\n   * If the target is a function, then a call to\n   *   proxy(...args)\n   * Triggers this trap\n   */\n  apply: function(target, thisBinding, args) {\n    var trap = this.getTrap(\"apply\");\n    if (trap === undefined) {\n      return Reflect.apply(target, thisBinding, args);\n    }\n\n    if (typeof this.target === \"function\") {\n      return trap.call(this.handler, target, thisBinding, args);\n    } else {\n      throw new TypeError(\"apply: \"+ target + \" is not a function\");\n    }\n  },\n\n  /**\n   * New trap that reifies [[Construct]].\n   * If the target is a function, then a call to\n   *   new proxy(...args)\n   * Triggers this trap\n   */\n  construct: function(target, args, newTarget) {\n    var trap = this.getTrap(\"construct\");\n    if (trap === undefined) {\n      return Reflect.construct(target, args, newTarget);\n    }\n\n    if (typeof target !== \"function\") {\n      throw new TypeError(\"new: \"+ target + \" is not a function\");\n    }\n\n    if (newTarget === undefined) {\n      newTarget = target;\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"new: \"+ newTarget + \" is not a function\");\n      }      \n    }\n    return trap.call(this.handler, target, args, newTarget);\n  }\n};\n\n// ---- end of the Validator handler wrapper handler ----\n\n// In what follows, a 'direct proxy' is a proxy\n// whose handler is a Validator. Such proxies can be made non-extensible,\n// sealed or frozen without losing the ability to trap.\n\n// maps direct proxies to their Validator handlers\nvar directProxies = new WeakMap();\n\n// patch Object.{preventExtensions,seal,freeze} so that\n// they recognize fixable proxies and act accordingly\nObject.preventExtensions = function(subject) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    if (vhandler.preventExtensions()) {\n      return subject;\n    } else {\n      throw new TypeError(\"preventExtensions on \"+subject+\" rejected\");\n    }\n  } else {\n    return prim_preventExtensions(subject);\n  }\n};\nObject.seal = function(subject) {\n  setIntegrityLevel(subject, \"sealed\");\n  return subject;\n};\nObject.freeze = function(subject) {\n  setIntegrityLevel(subject, \"frozen\");\n  return subject;\n};\nObject.isExtensible = Object_isExtensible = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.isExtensible();\n  } else {\n    return prim_isExtensible(subject);\n  }\n};\nObject.isSealed = Object_isSealed = function(subject) {\n  return testIntegrityLevel(subject, \"sealed\");\n};\nObject.isFrozen = Object_isFrozen = function(subject) {\n  return testIntegrityLevel(subject, \"frozen\");\n};\nObject.getPrototypeOf = Object_getPrototypeOf = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.getPrototypeOf();\n  } else {\n    return prim_getPrototypeOf(subject);\n  }\n};\n\n// patch Object.getOwnPropertyDescriptor to directly call\n// the Validator.prototype.getOwnPropertyDescriptor trap\n// This is to circumvent an assertion in the built-in Proxy\n// trapping mechanism of v8, which disallows that trap to\n// return non-configurable property descriptors (as per the\n// old Proxy design)\nObject.getOwnPropertyDescriptor = function(subject, name) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    return vhandler.getOwnPropertyDescriptor(name);\n  } else {\n    return prim_getOwnPropertyDescriptor(subject, name);\n  }\n};\n\n// patch Object.defineProperty to directly call\n// the Validator.prototype.defineProperty trap\n// This is to circumvent two issues with the built-in\n// trap mechanism:\n// 1) the current tracemonkey implementation of proxies\n// auto-completes 'desc', which is not correct. 'desc' should be\n// normalized, but not completed. Consider:\n// Object.defineProperty(proxy, 'foo', {enumerable:false})\n// This trap will receive desc =\n//  {value:undefined,writable:false,enumerable:false,configurable:false}\n// This will also set all other attributes to their default value,\n// which is unexpected and different from [[DefineOwnProperty]].\n// Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n// 2) the current spidermonkey implementation does not\n// throw an exception when this trap returns 'false', but instead silently\n// ignores the operation (this is regardless of strict-mode)\n// 2a) v8 does throw an exception for this case, but includes the rather\n//     unhelpful error message:\n// 'Proxy handler #<Object> returned false from 'defineProperty' trap'\nObject.defineProperty = function(subject, name, desc) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var normalizedDesc = normalizePropertyDescriptor(desc);\n    var success = vhandler.defineProperty(name, normalizedDesc);\n    if (success === false) {\n      throw new TypeError(\"can't redefine property '\"+name+\"'\");\n    }\n    return subject;\n  } else {\n    return prim_defineProperty(subject, name, desc);\n  }\n};\n\nObject.defineProperties = function(subject, descs) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var names = Object.keys(descs);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\"+name+\"'\");\n      }\n    }\n    return subject;\n  } else {\n    return prim_defineProperties(subject, descs);\n  }\n};\n\nObject.keys = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    var ownKeys = vHandler.ownKeys();\n    var result = [];\n    for (var i = 0; i < ownKeys.length; i++) {\n      var k = String(ownKeys[i]);\n      var desc = Object.getOwnPropertyDescriptor(subject, k);\n      if (desc !== undefined && desc.enumerable === true) {\n        result.push(k);\n      }\n    }\n    return result;\n  } else {\n    return prim_keys(subject);\n  }\n}\n\nObject.getOwnPropertyNames = Object_getOwnPropertyNames = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.ownKeys();\n  } else {\n    return prim_getOwnPropertyNames(subject);\n  }\n}\n\n// fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n// throws an error)\nif (prim_getOwnPropertySymbols !== undefined) {\n  Object.getOwnPropertySymbols = function(subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      // as this shim does not support symbols, a Proxy never advertises\n      // any symbol-valued own properties\n      return [];\n    } else {\n      return prim_getOwnPropertySymbols(subject);\n    }\n  };\n}\n\n// fixes issue #72 ('Illegal access' error when using Object.assign)\n// Object.assign polyfill based on a polyfill posted on MDN: \n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n//  Global_Objects/Object/assign\n// Note that this polyfill does not support Symbols, but this Proxy Shim\n// does not support Symbols anyway.\nif (prim_assign !== undefined) {\n  Object.assign = function (target) {\n    \n    // check if any argument is a proxy object\n    var noProxies = true;\n    for (var i = 0; i < arguments.length; i++) {\n      var vHandler = directProxies.get(arguments[i]);\n      if (vHandler !== undefined) {\n        noProxies = false;\n        break;\n      }\n    }\n    if (noProxies) {\n      // not a single argument is a proxy, perform built-in algorithm\n      return prim_assign.apply(Object, arguments);\n    }\n    \n    // there is at least one proxy argument, use the polyfill\n    \n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n}\n\n// returns whether an argument is a reference to an object,\n// which is legal as a WeakMap key.\nfunction isObject(arg) {\n  var type = typeof arg;\n  return (type === 'object' && arg !== null) || (type === 'function');\n};\n\n// a wrapper for WeakMap.get which returns the undefined value\n// for keys that are not objects (in which case the underlying\n// WeakMap would have thrown a TypeError).\nfunction safeWeakMapGet(map, key) {\n  return isObject(key) ? map.get(key) : undefined;\n};\n\n// returns a new function of zero arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a zero-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping0ArgMethod(primitive) {\n  return function builtin() {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target);\n    } else {\n      return primitive.call(this);\n    }\n  }\n};\n\n// returns a new function of 1 arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a 1-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping1ArgMethod(primitive) {\n  return function builtin(arg) {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target, arg);\n    } else {\n      return primitive.call(this, arg);\n    }\n  }\n};\n\nObject.prototype.valueOf =\n  makeUnwrapping0ArgMethod(Object.prototype.valueOf);\nObject.prototype.toString =\n  makeUnwrapping0ArgMethod(Object.prototype.toString);\nFunction.prototype.toString =\n  makeUnwrapping0ArgMethod(Function.prototype.toString);\nDate.prototype.toString =\n  makeUnwrapping0ArgMethod(Date.prototype.toString);\n\nObject.prototype.isPrototypeOf = function builtin(arg) {\n  // bugfix thanks to Bill Mark:\n  // built-in isPrototypeOf does not unwrap proxies used\n  // as arguments. So, we implement the builtin ourselves,\n  // based on the ECMAScript 6 spec. Our encoding will\n  // make sure that if a proxy is used as an argument,\n  // its getPrototypeOf trap will be called.\n  while (true) {\n    var vHandler2 = safeWeakMapGet(directProxies, arg);\n    if (vHandler2 !== undefined) {\n      arg = vHandler2.getPrototypeOf();\n      if (arg === null) {\n        return false;\n      } else if (sameValue(arg, this)) {\n        return true;\n      }\n    } else {\n      return prim_isPrototypeOf.call(this, arg);\n    }\n  }\n};\n\nArray.isArray = function(subject) {\n  var vHandler = safeWeakMapGet(directProxies, subject);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  } else {\n    return prim_isArray(subject);\n  }\n};\n\nfunction isProxyArray(arg) {\n  var vHandler = safeWeakMapGet(directProxies, arg);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  }\n  return false;\n}\n\n// Array.prototype.concat internally tests whether one of its\n// arguments is an Array, by checking whether [[Class]] == \"Array\"\n// As such, it will fail to recognize proxies-for-arrays as arrays.\n// We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n// by making a copy. This will trigger the exact same sequence of\n// traps on the proxy-for-array as if we would not have unwrapped it.\n// See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\nArray.prototype.concat = function(/*...args*/) {\n  var length;\n  for (var i = 0; i < arguments.length; i++) {\n    if (isProxyArray(arguments[i])) {\n      length = arguments[i].length;\n      arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n    }\n  }\n  return prim_concat.apply(this, arguments);\n};\n\n// setPrototypeOf support on platforms that support __proto__\n\nvar prim_setPrototypeOf = Object.setPrototypeOf;\n\n// patch and extract original __proto__ setter\nvar __proto__setter = (function() {\n  var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype,'__proto__');\n  if (protoDesc === undefined ||\n      typeof protoDesc.set !== \"function\") {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  // see if we can actually mutate a prototype with the generic setter\n  // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n  try {\n    protoDesc.set.call({},{});\n  } catch (e) {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  prim_defineProperty(Object.prototype, '__proto__', {\n    set: function(newProto) {\n      return Object.setPrototypeOf(this, Object(newProto));\n    }\n  });\n\n  return protoDesc.set;\n}());\n\nObject.setPrototypeOf = function(target, newProto) {\n  var handler = directProxies.get(target);\n  if (handler !== undefined) {\n    if (handler.setPrototypeOf(newProto)) {\n      return target;\n    } else {\n      throw new TypeError(\"proxy rejected prototype mutation\");\n    }\n  } else {\n    if (!Object_isExtensible(target)) {\n      throw new TypeError(\"can't set prototype on non-extensible object: \" +\n                          target);\n    }\n    if (prim_setPrototypeOf)\n      return prim_setPrototypeOf(target, newProto);\n\n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n      // throw new TypeError(\"prototype must be an object or null\")\n    }\n    __proto__setter.call(target, newProto);\n    return target;\n  }\n}\n\nObject.prototype.hasOwnProperty = function(name) {\n  var handler = safeWeakMapGet(directProxies, this);\n  if (handler !== undefined) {\n    var desc = handler.getOwnPropertyDescriptor(name);\n    return desc !== undefined;\n  } else {\n    return prim_hasOwnProperty.call(this, name);\n  }\n}\n\n// ============= Reflection module =============\n// see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\nvar Reflect = {\n  getOwnPropertyDescriptor: function(target, name) {\n    return Object.getOwnPropertyDescriptor(target, name);\n  },\n  defineProperty: function(target, name, desc) {\n\n    // if target is a proxy, invoke its \"defineProperty\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.defineProperty(target, name, desc);\n    }\n\n    // Implementation transliterated from [[DefineOwnProperty]]\n    // see ES5.1 section 8.12.9\n    // this is the _exact same algorithm_ as the isCompatibleDescriptor\n    // algorithm defined above, except that at every place it\n    // returns true, this algorithm actually does define the property.\n    var current = Object.getOwnPropertyDescriptor(target, name);\n    var extensible = Object.isExtensible(target);\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n    if (current === undefined && extensible === true) {\n      Object.defineProperty(target, name, desc); // should never fail\n      return true;\n    }\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n    if (isGenericDescriptor(desc)) {\n      // no further validation necessary\n    } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n    } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n    } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n    Object.defineProperty(target, name, desc); // should never fail\n    return true;\n  },\n  deleteProperty: function(target, name) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.delete(name);\n    }\n    \n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      return true;\n    }\n    if (desc.configurable === true) {\n      delete target[name];\n      return true;\n    }\n    return false;    \n  },\n  getPrototypeOf: function(target) {\n    return Object.getPrototypeOf(target);\n  },\n  setPrototypeOf: function(target, newProto) {\n    \n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.setPrototypeOf(newProto);\n    }\n    \n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n    }\n    \n    if (!Object_isExtensible(target)) {\n      return false;\n    }\n    \n    var current = Object.getPrototypeOf(target);\n    if (sameValue(current, newProto)) {\n      return true;\n    }\n    \n    if (prim_setPrototypeOf) {\n      try {\n        prim_setPrototypeOf(target, newProto);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    __proto__setter.call(target, newProto);\n    return true;\n  },\n  preventExtensions: function(target) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.preventExtensions();\n    }\n    prim_preventExtensions(target);\n    return true;\n  },\n  isExtensible: function(target) {\n    return Object.isExtensible(target);\n  },\n  has: function(target, name) {\n    return name in target;\n  },\n  get: function(target, name, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"get\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.get(receiver, name);\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      var proto = Object.getPrototypeOf(target);\n      if (proto === null) {\n        return undefined;\n      }\n      return Reflect.get(proto, name, receiver);\n    }\n    if (isDataDescriptor(desc)) {\n      return desc.value;\n    }\n    var getter = desc.get;\n    if (getter === undefined) {\n      return undefined;\n    }\n    return desc.get.call(receiver);\n  },\n  // Reflect.set implementation based on latest version of [[SetP]] at\n  // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n  set: function(target, name, value, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"set\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.set(receiver, name, value);\n    }\n\n    // first, check whether target has a non-writable property\n    // shadowing name on receiver\n    var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n    if (ownDesc === undefined) {\n      // name is not defined in target, search target's prototype\n      var proto = Object.getPrototypeOf(target);\n\n      if (proto !== null) {\n        // continue the search in target's prototype\n        return Reflect.set(proto, name, value, receiver);\n      }\n\n      // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n      // target was the last prototype, now we know that 'name' is not shadowed\n      // by an existing (accessor or data) property, so we can add the property\n      // to the initial receiver object\n      // (this branch will intentionally fall through to the code below)\n      ownDesc =\n        { value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n    }\n\n    // we now know that ownDesc !== undefined\n    if (isAccessorDescriptor(ownDesc)) {\n      var setter = ownDesc.set;\n      if (setter === undefined) return false;\n      setter.call(receiver, value); // assumes Function.prototype.call\n      return true;\n    }\n    // otherwise, isDataDescriptor(ownDesc) must be true\n    if (ownDesc.writable === false) return false;\n    // we found an existing writable data property on the prototype chain.\n    // Now update or add the data property on the receiver, depending on\n    // whether the receiver already defines the property or not.\n    var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n    if (existingDesc !== undefined) {\n      var updateDesc =\n        { value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable:     existingDesc.writable,\n          enumerable:   existingDesc.enumerable,\n          configurable: existingDesc.configurable };\n      Object.defineProperty(receiver, name, updateDesc);\n      return true;\n    } else {\n      if (!Object.isExtensible(receiver)) return false;\n      var newDesc =\n        { value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n      Object.defineProperty(receiver, name, newDesc);\n      return true;\n    }\n  },\n  /*invoke: function(target, name, args, receiver) {\n    receiver = receiver || target;\n\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.invoke(receiver, name, args);\n    }\n\n    var fun = Reflect.get(target, name, receiver);\n    return Function.prototype.apply.call(fun, receiver, args);\n  },*/\n  enumerate: function(target) {\n    var handler = directProxies.get(target);\n    var result;\n    if (handler !== undefined) {\n      // handler.enumerate should return an iterator directly, but the\n      // iterator gets converted to an array for backward-compat reasons,\n      // so we must re-iterate over the array\n      result = handler.enumerate(handler.target);\n    } else {\n      result = [];\n      for (var name in target) { result.push(name); };      \n    }\n    var l = +result.length;\n    var idx = 0;\n    return {\n      next: function() {\n        if (idx === l) return { done: true };\n        return { done: false, value: result[idx++] };\n      }\n    };\n  },\n  // imperfect ownKeys implementation: in ES6, should also include\n  // symbol-keyed properties.\n  ownKeys: function(target) {\n    return Object_getOwnPropertyNames(target);\n  },\n  apply: function(target, receiver, args) {\n    // target.apply(receiver, args)\n    return Function.prototype.apply.call(target, receiver, args);\n  },\n  construct: function(target, args, newTarget) {\n    // return new target(...args);\n\n    // if target is a proxy, invoke its \"construct\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.construct(handler.target, args, newTarget);\n    }\n    \n    if (typeof target !== \"function\") {\n      throw new TypeError(\"target is not a function: \" + target);\n    }\n    if (newTarget === undefined || newTarget === target) {\n      // If newTarget is undefined, then newTarget is set to `target` and\n      // `Reflect.construct(target, ...args)` becomes equivalent to\n      // `new target(...args)`\n      // if `target` is an ES2015 Class constructor, it must be called using\n      // the `new` operator. Hence we use the new operator on a bound function\n      // to trigger the [[Construct]] internal method. This technique will work \n      // for both plain constructor functions and ES2015 classes\n      return new (Function.prototype.bind.apply(target, [null].concat(args)));\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"newTarget is not a function: \" + target);\n      }\n      // if newTarget is a *different* constructor function, we need to\n      // emulate [[Construct]] by falling back to [[Call]] with a hand-crafted\n      // new instance inheriting from newTarget.prototype\n      // Unfortunately this won't work if target is an ES2015 Constructor\n      // function, whose [[Call]] method throws an error (it must be invoked\n      // using the `new` operator)\n      var proto = newTarget.prototype;\n      var instance = (Object(proto) === proto) ? Object.create(proto) : {};\n      var result = Function.prototype.apply.call(target, instance, args);\n      return Object(result) === result ? result : instance;\n    }\n  }\n};\n\n// feature-test whether the Reflect global exists\nif (global.Reflect !== undefined) {\n  // Reflect exists, add/override the shimmed methods\n  Object.getOwnPropertyNames(Reflect).forEach(function (key) {\n    global.Reflect[key] = Reflect[key];\n  });\n} else {\n  // Reflect doesn't exist, define it as the shimmed Reflect object\n  global.Reflect = Reflect;\n}\n\n// feature-test whether the Proxy global exists, with\n// the harmony-era Proxy.create API\nif (typeof Proxy !== \"undefined\" &&\n    typeof Proxy.create !== \"undefined\") {\n\n  var primCreate = Proxy.create,\n      primCreateFunction = Proxy.createFunction;\n\n  var revokedHandler = primCreate({\n    get: function() { throw new TypeError(\"proxy is revoked\"); }\n  });\n\n  global.Proxy = function(target, handler) {\n    // check that target is an Object\n    if (Object(target) !== target) {\n      throw new TypeError(\"Proxy target must be an Object, given \"+target);\n    }\n    // check that handler is an Object\n    if (Object(handler) !== handler) {\n      throw new TypeError(\"Proxy handler must be an Object, given \"+handler);\n    }\n\n    var vHandler = new Validator(target, handler);\n    var proxy;\n    if (typeof target === \"function\") {\n      proxy = primCreateFunction(vHandler,\n        // call trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        },\n        // construct trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n    } else {\n      proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n    }\n    directProxies.set(proxy, vHandler);\n    return proxy;\n  };\n\n  global.Proxy.revocable = function(target, handler) {\n    var proxy = new Proxy(target, handler);\n    var revoke = function() {\n      var vHandler = directProxies.get(proxy);\n      if (vHandler !== null) {\n        vHandler.target  = null;\n        vHandler.handler = revokedHandler;\n      }\n      return undefined;\n    };\n    return {proxy: proxy, revoke: revoke};\n  }\n  \n  // add the old Proxy.create and Proxy.createFunction methods\n  // so old code that still depends on the harmony-era Proxy object\n  // is not broken. Also ensures that multiple versions of this\n  // library should load fine\n  global.Proxy.create = primCreate;\n  global.Proxy.createFunction = primCreateFunction;\n\n} else {\n  // Proxy global not defined, or old API not available\n  if (typeof Proxy === \"undefined\") {\n    // Proxy global not defined, add a Proxy function stub\n    global.Proxy = function(_target, _handler) {\n      throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n    };\n  }\n  // Proxy global defined but old API not available\n  // presumably Proxy global already supports new API, leave untouched\n}\n\n// for node.js modules, export every property in the Reflect object\n// as part of the module interface\nif (typeof exports !== 'undefined') {\n  Object.keys(Reflect).forEach(function (key) {\n    exports[key] = Reflect[key];\n  });\n}\n\n// function-as-module pattern\n}(typeof exports !== 'undefined' ? global : this));"]},"metadata":{},"sourceType":"script"}